<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>Splat Viewer - Splat and Treat</title>
    <style>
      body {
        margin: 0;
        background: #1a1a2e;
        overflow: hidden;
        touch-action: none;
      }
      .overlay {
        position: absolute;
        z-index: 10;
        font-family:
          system-ui,
          -apple-system,
          sans-serif;
      }
      .back-btn {
        position: absolute;
        top: 1rem;
        left: 1rem;
        padding: 0.5rem 1rem;
        background: rgba(138, 43, 226, 0.8);
        color: white;
        border: none;
        border-radius: 0.5rem;
        cursor: pointer;
        font-size: 1rem;
      }
      .back-btn:hover {
        background: rgba(138, 43, 226, 1);
      }
      .info {
        position: absolute;
        bottom: 1rem;
        left: 1rem;
        background: rgba(0, 0, 0, 0.6);
        padding: 0.5rem 1rem;
        border-radius: 0.5rem;
        color: white;
      }
      .info.mobile {
        bottom: 10rem;
      }
      .info h3 {
        color: #ff6600;
        margin: 0 0 0.25rem 0;
      }
      .info p {
        color: #999;
        font-size: 0.875rem;
        margin: 0;
      }
      .loading {
        position: absolute;
        inset: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        background: #1a1a2e;
        background-size: contain;
        background-position: center;
        background-repeat: no-repeat;
        z-index: 30;
        color: white;
        font-family: system-ui;
      }
      .loading.hidden {
        display: none;
      }
      .spinner {
        width: 4rem;
        height: 4rem;
        border: 4px solid #ff6600;
        border-top-color: transparent;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-bottom: 1rem;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }
      .progress-container {
        width: 200px;
        height: 6px;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 3px;
        margin-top: 1rem;
        overflow: hidden;
      }
      .progress-bar {
        height: 100%;
        background: linear-gradient(90deg, #ff6600, #ff9933);
        border-radius: 3px;
        width: 0%;
        transition: width 0.15s ease-out;
      }
      .progress-text {
        margin-top: 0.5rem;
        font-size: 0.875rem;
        color: #999;
      }
      /* Mobile joystick */
      #joystick-zone {
        position: absolute;
        bottom: 2rem;
        left: 2rem;
        width: 120px;
        height: 120px;
        z-index: 20;
        display: none;
      }
      #joystick-zone.visible {
        display: block;
      }
      #joystick-base {
        position: absolute;
        width: 100%;
        height: 100%;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.15);
        border: 2px solid rgba(255, 255, 255, 0.3);
      }
      #joystick-stick {
        position: absolute;
        width: 50px;
        height: 50px;
        border-radius: 50%;
        background: rgba(255, 102, 0, 0.7);
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        pointer-events: none;
      }
      /* Mode toggle button */
      .mode-toggle {
        position: absolute;
        top: 1rem;
        right: 1rem;
        padding: 0.5rem 1rem;
        background: rgba(255, 102, 0, 0.8);
        color: white;
        border: none;
        border-radius: 0.5rem;
        cursor: pointer;
        font-size: 1rem;
        font-family:
          system-ui,
          -apple-system,
          sans-serif;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        transition:
          background 0.2s,
          transform 0.1s;
      }
      .mode-toggle:hover {
        background: rgba(255, 102, 0, 1);
      }
      .mode-toggle:active {
        transform: scale(0.98);
      }
      .mode-toggle .icon {
        font-size: 1.2rem;
      }
      .mode-toggle[data-mode='edit'] {
        background: rgba(138, 43, 226, 0.8);
      }
      .mode-toggle[data-mode='edit']:hover {
        background: rgba(138, 43, 226, 1);
      }

      /* Mode indicator badge */
      .mode-badge {
        position: absolute;
        top: 1rem;
        left: 50%;
        transform: translateX(-50%);
        padding: 0.25rem 0.75rem;
        background: rgba(0, 0, 0, 0.6);
        color: #ff6600;
        border-radius: 1rem;
        font-size: 0.75rem;
        font-family:
          system-ui,
          -apple-system,
          sans-serif;
        text-transform: uppercase;
        letter-spacing: 0.1em;
        opacity: 0;
        transition: opacity 0.3s;
      }
      .mode-badge.visible {
        opacity: 1;
      }
      /* Treat selection panel */
      .treat-panel {
        position: absolute;
        top: 4rem;
        right: 1rem;
        width: 300px;
        background: rgba(0, 0, 0, 0.9);
        border-radius: 0.75rem;
        padding: 1rem;
        color: white;
        font-family:
          system-ui,
          -apple-system,
          sans-serif;
        display: none;
        border: 1px solid rgba(138, 43, 226, 0.5);
        max-height: calc(100vh - 6rem);
        overflow-y: auto;
      }
      .treat-panel.visible {
        display: block;
      }
      .treat-panel h4 {
        margin: 0 0 0.75rem 0;
        color: #ff6600;
        font-size: 0.875rem;
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }
      .treat-panel label {
        display: block;
        margin-bottom: 0.25rem;
        color: #ccc;
        font-size: 0.75rem;
      }
      .treat-panel input[type='text'],
      .treat-panel textarea {
        width: 100%;
        padding: 0.5rem;
        border: 1px solid rgba(138, 43, 226, 0.5);
        border-radius: 0.375rem;
        background: rgba(255, 255, 255, 0.1);
        color: white;
        font-size: 0.875rem;
        margin-bottom: 0.75rem;
        box-sizing: border-box;
      }
      .treat-panel input[type='text']:focus,
      .treat-panel textarea:focus {
        outline: none;
        border-color: #ff6600;
      }
      .treat-panel textarea {
        resize: vertical;
        min-height: 60px;
      }
      .treat-panel .char-count {
        text-align: right;
        font-size: 0.7rem;
        color: #666;
        margin-top: -0.5rem;
        margin-bottom: 0.5rem;
      }
      .treat-panel .char-count.warning {
        color: #ff6600;
      }
      .treat-panel .char-count.error {
        color: #ff0000;
      }
      .treat-panel button {
        width: 100%;
        padding: 0.5rem;
        border: none;
        border-radius: 0.375rem;
        cursor: pointer;
        font-size: 0.875rem;
        margin-bottom: 0.5rem;
        transition:
          background 0.2s,
          transform 0.1s;
      }
      .treat-panel button:active {
        transform: scale(0.98);
      }
      .treat-panel .preset-btn {
        background: rgba(138, 43, 226, 0.6);
        color: white;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        justify-content: center;
      }
      .treat-panel .preset-btn:hover {
        background: rgba(138, 43, 226, 0.8);
      }
      .treat-panel .preset-btn.selected {
        background: rgba(255, 102, 0, 0.8);
        border: 2px solid #ff6600;
      }
      .treat-panel .load-btn {
        background: rgba(255, 102, 0, 0.8);
        color: white;
      }
      .treat-panel .load-btn:hover {
        background: rgba(255, 102, 0, 1);
      }
      .treat-panel .load-btn:disabled {
        background: rgba(100, 100, 100, 0.5);
        cursor: not-allowed;
      }
      .treat-panel .cancel-btn {
        background: rgba(255, 0, 0, 0.6);
        color: white;
      }
      .treat-panel .cancel-btn:hover {
        background: rgba(255, 0, 0, 0.8);
      }
      .treat-panel .divider {
        border-top: 1px solid rgba(255, 255, 255, 0.1);
        margin: 1rem 0;
      }
      .treat-panel .status {
        padding: 0.5rem;
        border-radius: 0.375rem;
        font-size: 0.75rem;
        margin-bottom: 0.5rem;
      }
      .treat-panel .status.ready {
        background: rgba(0, 255, 0, 0.2);
        color: #00ff00;
      }
      .treat-panel .status.loading {
        background: rgba(255, 165, 0, 0.2);
        color: #ffa500;
      }
      .treat-panel .status.error {
        background: rgba(255, 0, 0, 0.2);
        color: #ff6666;
      }
      .treat-panel .placed-treats {
        margin-top: 1rem;
      }
      .treat-panel .placed-treats h5 {
        margin: 0 0 0.5rem 0;
        color: #999;
        font-size: 0.75rem;
      }
      .treat-panel .treat-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.375rem 0.5rem;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid transparent;
        border-radius: 0.25rem;
        margin-bottom: 0.25rem;
        font-size: 0.75rem;
        cursor: pointer;
        transition:
          background 0.15s,
          border-color 0.15s;
      }
      .treat-panel .treat-item:hover {
        background: rgba(255, 255, 255, 0.1);
      }
      .treat-panel .treat-item .treat-name {
        color: #ccc;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        max-width: 180px;
      }
      .treat-panel .treat-item .treat-actions {
        display: flex;
        gap: 0.25rem;
        flex-shrink: 0;
      }
      .treat-panel .treat-item .duplicate-btn {
        background: rgba(138, 43, 226, 0.4);
        color: white;
        border: none;
        border-radius: 0.25rem;
        padding: 0.125rem 0.375rem;
        cursor: pointer;
        font-size: 0.7rem;
        width: auto;
        margin: 0;
      }
      .treat-panel .treat-item .duplicate-btn:hover {
        background: rgba(138, 43, 226, 0.7);
      }
      .treat-panel .treat-item .delete-btn {
        background: rgba(255, 0, 0, 0.3);
        color: white;
        border: none;
        border-radius: 0.25rem;
        padding: 0.125rem 0.375rem;
        cursor: pointer;
        font-size: 0.7rem;
        width: auto;
        margin: 0;
      }
      .treat-panel .treat-item .delete-btn:hover {
        background: rgba(255, 0, 0, 0.6);
      }
      .treat-panel .treat-item .edit-btn {
        background: rgba(255, 102, 0, 0.3);
        color: white;
        border: none;
        border-radius: 0.25rem;
        padding: 0.125rem 0.375rem;
        cursor: pointer;
        font-size: 0.7rem;
        width: auto;
        margin: 0;
      }
      .treat-panel .treat-item .edit-btn:hover {
        background: rgba(255, 102, 0, 0.6);
      }
      .treat-panel .treat-item.selected {
        background: rgba(255, 102, 0, 0.2);
        border-color: rgba(255, 102, 0, 0.5);
      }
      .treat-panel .treat-item.selected:hover {
        background: rgba(255, 102, 0, 0.25);
      }

      /* ============================================
         Treat Editor Panel - Contextual editing UI
         Shows when a placed treat is selected
         ============================================ */
      .treat-editor {
        position: absolute;
        bottom: 1rem;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(15, 15, 25, 0.95);
        border: 1px solid rgba(255, 102, 0, 0.6);
        border-radius: 1rem;
        padding: 1rem 1.25rem;
        color: white;
        font-family:
          system-ui,
          -apple-system,
          sans-serif;
        display: none;
        z-index: 35;
        min-width: 320px;
        max-width: 400px;
        backdrop-filter: blur(10px);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      }
      .treat-editor.visible {
        display: block;
      }

      .treat-editor-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.75rem;
        padding-bottom: 0.5rem;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }
      .treat-editor-header h4 {
        margin: 0;
        font-size: 0.9rem;
        color: #ff6600;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }
      .treat-editor-header .close-editor {
        background: none;
        border: none;
        color: #888;
        font-size: 1.25rem;
        cursor: pointer;
        padding: 0.25rem;
        line-height: 1;
        border-radius: 0.25rem;
        transition:
          color 0.2s,
          background 0.2s;
      }
      .treat-editor-header .close-editor:hover {
        color: white;
        background: rgba(255, 255, 255, 0.1);
      }

      .treat-editor-tabs {
        display: flex;
        gap: 0.25rem;
        margin-bottom: 1rem;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 0.5rem;
        padding: 0.25rem;
      }
      .treat-editor-tab {
        flex: 1;
        padding: 0.5rem 0.75rem;
        background: transparent;
        border: none;
        color: #888;
        font-size: 0.8rem;
        cursor: pointer;
        border-radius: 0.375rem;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.375rem;
      }
      .treat-editor-tab:hover {
        color: #ccc;
      }
      .treat-editor-tab.active {
        background: rgba(255, 102, 0, 0.3);
        color: #ff6600;
      }
      .treat-editor-tab .tab-icon {
        font-size: 1rem;
      }

      .treat-editor-content {
        min-height: 80px;
      }
      .treat-editor-section {
        display: none;
      }
      .treat-editor-section.active {
        display: block;
      }

      /* Message editing section */
      .treat-editor .message-input {
        width: 100%;
        padding: 0.75rem;
        border: 1px solid rgba(255, 102, 0, 0.3);
        border-radius: 0.5rem;
        background: rgba(255, 255, 255, 0.05);
        color: white;
        font-size: 0.9rem;
        resize: none;
        min-height: 80px;
        box-sizing: border-box;
        font-family: inherit;
        line-height: 1.5;
      }
      .treat-editor .message-input:focus {
        outline: none;
        border-color: #ff6600;
        background: rgba(255, 255, 255, 0.08);
      }
      .treat-editor .message-input::placeholder {
        color: #666;
      }

      .treat-editor .char-counter {
        text-align: right;
        font-size: 0.7rem;
        color: #666;
        margin-top: 0.375rem;
      }
      .treat-editor .char-counter.warning {
        color: #ff6600;
      }
      .treat-editor .char-counter.error {
        color: #ff4444;
      }

      /* Position section */
      .treat-editor .position-hint {
        font-size: 0.75rem;
        color: #888;
        margin-bottom: 0.75rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }
      .treat-editor .position-hint .hint-icon {
        font-size: 1rem;
        opacity: 0.7;
      }
      .treat-editor .position-controls {
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
      }
      .treat-editor .position-btn {
        flex: 1;
        min-width: 80px;
        padding: 0.625rem 0.75rem;
        background: rgba(138, 43, 226, 0.4);
        border: 1px solid rgba(138, 43, 226, 0.5);
        color: white;
        border-radius: 0.5rem;
        cursor: pointer;
        font-size: 0.8rem;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.375rem;
        transition: all 0.2s;
      }
      .treat-editor .position-btn:hover {
        background: rgba(138, 43, 226, 0.6);
        border-color: rgba(138, 43, 226, 0.8);
      }
      .treat-editor .position-btn.active {
        background: rgba(255, 102, 0, 0.5);
        border-color: #ff6600;
      }
      .treat-editor .position-btn .btn-icon {
        font-size: 1rem;
      }

      /* Action buttons */
      .treat-editor-actions {
        display: flex;
        gap: 0.5rem;
        margin-top: 1rem;
        padding-top: 0.75rem;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
      }
      .treat-editor .action-btn {
        flex: 1;
        padding: 0.625rem 1rem;
        border: none;
        border-radius: 0.5rem;
        cursor: pointer;
        font-size: 0.85rem;
        font-weight: 500;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.375rem;
        transition: all 0.2s;
      }
      .treat-editor .save-btn {
        background: linear-gradient(135deg, #ff6600, #ff8833);
        color: white;
      }
      .treat-editor .save-btn:hover {
        background: linear-gradient(135deg, #ff7711, #ff9944);
        transform: translateY(-1px);
      }
      .treat-editor .delete-btn {
        background: rgba(255, 60, 60, 0.2);
        color: #ff6666;
        border: 1px solid rgba(255, 60, 60, 0.3);
      }
      .treat-editor .delete-btn:hover {
        background: rgba(255, 60, 60, 0.4);
        border-color: rgba(255, 60, 60, 0.6);
      }
      .treat-editor .duplicate-btn {
        background: rgba(138, 43, 226, 0.3);
        color: #bb88ff;
        border: 1px solid rgba(138, 43, 226, 0.4);
      }
      .treat-editor .duplicate-btn:hover {
        background: rgba(138, 43, 226, 0.5);
      }

      /* Toast notification for save feedback */
      .treat-editor-toast {
        position: fixed;
        bottom: 8rem;
        left: 50%;
        transform: translateX(-50%) translateY(20px);
        background: rgba(0, 200, 100, 0.9);
        color: white;
        padding: 0.625rem 1.25rem;
        border-radius: 0.5rem;
        font-size: 0.85rem;
        font-weight: 500;
        opacity: 0;
        transition: all 0.3s ease;
        pointer-events: none;
        z-index: 40;
      }
      .treat-editor-toast.visible {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }
      .treat-editor-toast.error {
        background: rgba(255, 60, 60, 0.9);
      }
      /* Text message modal */
      .message-modal {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 100;
      }
      .message-modal.visible {
        display: flex;
      }
      .message-modal .modal-content {
        background: rgba(26, 26, 46, 0.95);
        border: 2px solid #ff6600;
        border-radius: 1rem;
        padding: 1.5rem;
        max-width: 400px;
        width: 90%;
        color: white;
        font-family:
          system-ui,
          -apple-system,
          sans-serif;
      }
      .message-modal h3 {
        margin: 0 0 1rem 0;
        color: #ff6600;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }
      .message-modal p {
        margin: 0;
        line-height: 1.6;
        color: #eee;
      }
      .message-modal .close-btn {
        margin-top: 1rem;
        width: 100%;
        padding: 0.5rem;
        background: rgba(138, 43, 226, 0.8);
        color: white;
        border: none;
        border-radius: 0.5rem;
        cursor: pointer;
        font-size: 1rem;
      }
      .message-modal .close-btn:hover {
        background: rgba(138, 43, 226, 1);
      }

      /* Proximity message indicator (shows when near a message bottle in explore mode) */
      .proximity-indicator {
        position: absolute;
        bottom: 6rem;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.8);
        border: 2px solid #ff6600;
        border-radius: 0.75rem;
        padding: 0.75rem 1.25rem;
        color: white;
        font-family:
          system-ui,
          -apple-system,
          sans-serif;
        display: none;
        align-items: center;
        gap: 0.75rem;
        z-index: 25;
        animation: proximity-pulse 2s ease-in-out infinite;
        cursor: pointer;
        transition:
          transform 0.1s,
          background 0.2s;
      }
      .proximity-indicator:hover {
        background: rgba(0, 0, 0, 0.95);
        transform: translateX(-50%) scale(1.05);
      }
      .proximity-indicator.visible {
        display: flex;
      }
      .proximity-indicator .icon {
        font-size: 1.5rem;
      }
      .proximity-indicator .text {
        font-size: 0.875rem;
        color: #eee;
      }
      .proximity-indicator .hint {
        font-size: 0.7rem;
        color: #999;
        margin-top: 0.125rem;
      }
      @keyframes proximity-pulse {
        0%,
        100% {
          border-color: #ff6600;
          box-shadow: 0 0 10px rgba(255, 102, 0, 0.3);
        }
        50% {
          border-color: #ff9933;
          box-shadow: 0 0 20px rgba(255, 102, 0, 0.5);
        }
      }

      /* Center screen reticle (explore mode) */
      .reticle {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 8px;
        height: 8px;
        pointer-events: none;
        z-index: 15;
        opacity: 0.4;
        transition:
          opacity 0.2s,
          transform 0.15s;
      }
      .reticle::before,
      .reticle::after {
        content: '';
        position: absolute;
        background: white;
        border-radius: 1px;
      }
      .reticle::before {
        width: 2px;
        height: 100%;
        left: 50%;
        transform: translateX(-50%);
      }
      .reticle::after {
        width: 100%;
        height: 2px;
        top: 50%;
        transform: translateY(-50%);
      }
      .reticle.active {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.3);
      }
      .reticle.active::before,
      .reticle.active::after {
        background: #00ffaa;
      }
      .reticle.hidden {
        opacity: 0;
      }

      /* Admin Camera Calibration Panel */
      .admin-panel {
        position: absolute;
        bottom: 1rem;
        right: 1rem;
        width: 320px;
        background: rgba(0, 0, 0, 0.95);
        border-radius: 0.75rem;
        padding: 1rem;
        color: white;
        font-family: 'Monaco', 'Menlo', monospace;
        font-size: 0.75rem;
        display: none;
        border: 2px solid rgba(0, 255, 136, 0.6);
        z-index: 50;
      }
      .admin-panel.visible {
        display: block;
      }
      .admin-panel h4 {
        margin: 0 0 0.75rem 0;
        color: #00ff88;
        font-size: 0.875rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }
      .admin-panel .coord-group {
        margin-bottom: 0.75rem;
      }
      .admin-panel .coord-label {
        color: #888;
        font-size: 0.65rem;
        text-transform: uppercase;
        margin-bottom: 0.25rem;
      }
      .admin-panel .coord-value {
        background: rgba(0, 255, 136, 0.1);
        padding: 0.375rem 0.5rem;
        border-radius: 0.25rem;
        font-family: 'Monaco', 'Menlo', monospace;
        color: #00ff88;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .admin-panel .coord-value span {
        flex: 1;
      }
      .admin-panel .copy-btn {
        background: rgba(0, 255, 136, 0.3);
        border: none;
        color: white;
        padding: 0.25rem 0.5rem;
        border-radius: 0.25rem;
        cursor: pointer;
        font-size: 0.65rem;
        margin-left: 0.5rem;
      }
      .admin-panel .copy-btn:hover {
        background: rgba(0, 255, 136, 0.5);
      }
      .admin-panel .copy-btn.copied {
        background: rgba(0, 255, 136, 0.8);
      }
      .admin-panel .divider {
        border-top: 1px solid rgba(0, 255, 136, 0.2);
        margin: 0.75rem 0;
      }
      .admin-panel .hotkeys {
        color: #666;
        font-size: 0.65rem;
        line-height: 1.6;
      }
      .admin-panel .hotkeys kbd {
        background: rgba(255, 255, 255, 0.1);
        padding: 0.125rem 0.375rem;
        border-radius: 0.25rem;
        margin-right: 0.25rem;
      }
      .admin-panel .export-btn {
        width: 100%;
        background: rgba(0, 255, 136, 0.6);
        border: none;
        color: #000;
        padding: 0.5rem;
        border-radius: 0.375rem;
        cursor: pointer;
        font-size: 0.75rem;
        font-weight: bold;
        margin-top: 0.5rem;
      }
      .admin-panel .export-btn:hover {
        background: rgba(0, 255, 136, 0.8);
      }
      .admin-panel .coord-inputs {
        display: flex;
        gap: 0.25rem;
        margin-bottom: 0.5rem;
      }
      .admin-panel .coord-inputs input {
        flex: 1;
        background: rgba(0, 255, 136, 0.15);
        border: 1px solid rgba(0, 255, 136, 0.3);
        border-radius: 0.25rem;
        color: #00ff88;
        padding: 0.375rem;
        font-family: 'Monaco', 'Menlo', monospace;
        font-size: 0.7rem;
        width: 60px;
        text-align: center;
      }
      .admin-panel .coord-inputs input:focus {
        outline: none;
        border-color: #00ff88;
        background: rgba(0, 255, 136, 0.25);
      }
      .admin-panel .apply-btn {
        width: 100%;
        background: rgba(255, 165, 0, 0.6);
        border: none;
        color: #000;
        padding: 0.375rem;
        border-radius: 0.375rem;
        cursor: pointer;
        font-size: 0.7rem;
        font-weight: bold;
        margin-top: 0.25rem;
      }
      .admin-panel .apply-btn:hover {
        background: rgba(255, 165, 0, 0.8);
      }
      .admin-toast {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 255, 136, 0.9);
        color: #000;
        padding: 0.75rem 1.5rem;
        border-radius: 0.5rem;
        font-family: system-ui;
        font-weight: bold;
        z-index: 100;
        opacity: 0;
        transition: opacity 0.2s;
        pointer-events: none;
      }
      .admin-toast.visible {
        opacity: 1;
      }

      /* Selection and hover visual effects */
      .selection-outline {
        position: absolute;
        pointer-events: none;
        border: 2px solid #ff6600;
        border-radius: 4px;
        box-shadow:
          0 0 10px rgba(255, 102, 0, 0.5),
          0 0 20px rgba(255, 102, 0, 0.3);
        animation: selection-pulse 2s ease-in-out infinite;
        z-index: 5;
      }
      @keyframes selection-pulse {
        0%,
        100% {
          box-shadow:
            0 0 10px rgba(255, 102, 0, 0.5),
            0 0 20px rgba(255, 102, 0, 0.3);
        }
        50% {
          box-shadow:
            0 0 15px rgba(255, 102, 0, 0.7),
            0 0 30px rgba(255, 102, 0, 0.5);
        }
      }

      /* Share button */
      .share-btn {
        position: absolute;
        top: 1rem;
        right: 8rem;
        padding: 0.5rem 1rem;
        background: rgba(0, 180, 100, 0.8);
        color: white;
        border: none;
        border-radius: 0.5rem;
        cursor: pointer;
        font-size: 1rem;
        font-family: system-ui, -apple-system, sans-serif;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        transition: background 0.2s, transform 0.1s;
        z-index: 10;
      }
      .share-btn:hover {
        background: rgba(0, 200, 120, 1);
      }
      .share-btn:active {
        transform: scale(0.98);
      }
      .share-btn:disabled {
        background: rgba(100, 100, 100, 0.5);
        cursor: not-allowed;
      }
      .share-btn .icon {
        font-size: 1.2rem;
      }

      /* Share modal */
      .share-modal {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.85);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 200;
      }
      .share-modal.visible {
        display: flex;
      }
      .share-modal .modal-content {
        background: rgba(26, 26, 46, 0.98);
        border: 2px solid #00b464;
        border-radius: 1rem;
        padding: 1.5rem;
        max-width: 450px;
        width: 90%;
        color: white;
        font-family: system-ui, -apple-system, sans-serif;
        box-shadow: 0 8px 32px rgba(0, 180, 100, 0.3);
      }
      .share-modal h3 {
        margin: 0 0 1rem 0;
        color: #00b464;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 1.25rem;
      }
      .share-modal .share-status {
        padding: 0.75rem;
        border-radius: 0.5rem;
        margin-bottom: 1rem;
        font-size: 0.875rem;
      }
      .share-modal .share-status.saving {
        background: rgba(255, 165, 0, 0.2);
        color: #ffa500;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }
      .share-modal .share-status.success {
        background: rgba(0, 255, 100, 0.15);
        color: #00ff64;
      }
      .share-modal .share-status.error {
        background: rgba(255, 0, 0, 0.2);
        color: #ff6666;
      }
      .share-modal .share-url-container {
        display: flex;
        gap: 0.5rem;
        margin-bottom: 1rem;
      }
      .share-modal .share-url-input {
        flex: 1;
        padding: 0.75rem;
        border: 1px solid rgba(0, 180, 100, 0.5);
        border-radius: 0.5rem;
        background: rgba(255, 255, 255, 0.1);
        color: white;
        font-size: 0.875rem;
        font-family: monospace;
      }
      .share-modal .share-url-input:focus {
        outline: none;
        border-color: #00b464;
      }
      .share-modal .copy-url-btn {
        padding: 0.75rem 1rem;
        background: rgba(0, 180, 100, 0.8);
        color: white;
        border: none;
        border-radius: 0.5rem;
        cursor: pointer;
        font-size: 0.875rem;
        transition: background 0.2s;
        white-space: nowrap;
      }
      .share-modal .copy-url-btn:hover {
        background: rgba(0, 200, 120, 1);
      }
      .share-modal .copy-url-btn.copied {
        background: rgba(0, 255, 100, 0.8);
      }
      .share-modal .share-info {
        font-size: 0.8rem;
        color: #888;
        margin-bottom: 1rem;
        line-height: 1.5;
      }
      .share-modal .modal-actions {
        display: flex;
        gap: 0.5rem;
        justify-content: flex-end;
      }
      .share-modal .close-btn {
        padding: 0.5rem 1.5rem;
        background: rgba(138, 43, 226, 0.6);
        color: white;
        border: none;
        border-radius: 0.5rem;
        cursor: pointer;
        font-size: 1rem;
        transition: background 0.2s;
      }
      .share-modal .close-btn:hover {
        background: rgba(138, 43, 226, 0.8);
      }
      .share-modal .spinner-small {
        width: 1rem;
        height: 1rem;
        border: 2px solid #ffa500;
        border-top-color: transparent;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }
      .share-modal .treat-count {
        font-size: 0.875rem;
        color: #ccc;
        margin-bottom: 0.5rem;
      }
    </style>
  </head>
  <body>
    <div class="loading" id="loading">
      <div class="spinner"></div>
      <p id="loading-status">Loading world...</p>
      <div class="progress-container">
        <div class="progress-bar" id="progress-bar"></div>
      </div>
      <p class="progress-text" id="progress-text">0%</p>
    </div>

    <button class="back-btn overlay" onclick="window.location.href = '/'">‚Üê Back to Worlds</button>

    <!-- Mode toggle button -->
    <button class="mode-toggle overlay" id="mode-toggle" data-mode="explore">
      <span class="icon">üëÅÔ∏è</span>
      <span id="mode-label">Explore</span>
    </button>

    <!-- Share button -->
    <button class="share-btn overlay" id="share-btn">
      <span class="icon">üîó</span>
      <span>Share</span>
    </button>

    <!-- Share modal -->
    <div class="share-modal" id="share-modal">
      <div class="modal-content">
        <h3><span>üîó</span> Share Your Creation</h3>
        <div class="treat-count" id="share-treat-count">0 treats placed</div>
        <div class="share-status saving" id="share-status" style="display: none;">
          <div class="spinner-small"></div>
          <span>Saving scene...</span>
        </div>
        <div class="share-url-container" id="share-url-container" style="display: none;">
          <input type="text" class="share-url-input" id="share-url-input" readonly />
          <button class="copy-url-btn" id="copy-url-btn">üìã Copy</button>
        </div>
        <div class="share-info">
          Share this link with friends to let them explore your decorated world!
          They'll see all the treats you've placed.
        </div>
        <div class="modal-actions">
          <button class="close-btn" id="close-share-modal-btn">Close</button>
        </div>
      </div>
    </div>

    <!-- Mode change indicator -->
    <div class="mode-badge overlay" id="mode-badge">Explore Mode</div>

    <!-- Treat selection panel (shown in edit mode) -->
    <div class="treat-panel overlay" id="treat-panel">
      <h4>üéÉ Place Treats</h4>

      <!-- Status indicator -->
      <div class="status" id="treat-status" style="display: none"></div>

      <!-- Preset buttons -->
      <label>Quick Presets</label>
      <button
        class="preset-btn selected"
        id="preset-geomarker"
        data-url="https://s3.amazonaws.com/worldmatica/geomarker_animated.glb"
      >
        <span>üìç</span> Geomarker Pin
      </button>
      <button
        class="preset-btn"
        id="preset-bottle"
        data-url="https://s3.amazonaws.com/worldmatica/message_in_a_bottle.glb"
      >
        <span>üçæ</span> Message in a Bottle
      </button>

      <div class="divider"></div>

      <!-- Custom GLB input -->
      <label for="glb-url">Custom GLB URL</label>
      <input type="text" id="glb-url" placeholder="https://example.com/model.glb" />

      <label for="treat-text">Attached Message (optional)</label>
      <textarea
        id="treat-text"
        placeholder="Leave a message for others to find..."
        maxlength="280"
      ></textarea>
      <div class="char-count" id="char-count">0 / 280</div>

      <!-- Position offset for models with off-center pivots -->
      <label>Position Offset (Y = up)</label>
      <div style="display: flex; gap: 0.5rem; margin-bottom: 0.75rem">
        <input
          type="number"
          id="offset-x"
          placeholder="X"
          value="0"
          step="0.1"
          style="width: 33%"
        />
        <input
          type="number"
          id="offset-y"
          placeholder="Y"
          value="0"
          step="0.1"
          style="width: 33%"
        />
        <input
          type="number"
          id="offset-z"
          placeholder="Z"
          value="0"
          step="0.1"
          style="width: 33%"
        />
      </div>

      <button class="load-btn" id="load-treat-btn">Load & Select Treat</button>

      <!-- Cancel placement button (shown when in placement mode) -->
      <button class="cancel-btn" id="cancel-placement-btn" style="display: none">
        ‚úï Cancel Placement
      </button>

      <!-- Placed treats list -->
      <div class="placed-treats" id="placed-treats-section" style="display: none">
        <div class="divider"></div>
        <h5>Placed Treats</h5>
        <div id="placed-treats-list"></div>
      </div>
    </div>

    <!-- Message display modal -->
    <div class="message-modal" id="message-modal">
      <div class="modal-content">
        <h3><span>üìú</span> Message Found!</h3>
        <p id="message-content"></p>
        <button class="close-btn" id="close-modal-btn">Close</button>
      </div>
    </div>

    <!-- Treat Editor Panel (contextual editing when treat is selected) -->
    <div class="treat-editor" id="treat-editor">
      <div class="treat-editor-header">
        <h4><span>‚úèÔ∏è</span> Edit Treat</h4>
        <button class="close-editor" id="close-editor-btn" title="Close (ESC)">√ó</button>
      </div>

      <div class="treat-editor-tabs">
        <button class="treat-editor-tab active" data-tab="message">
          <span class="tab-icon">üí¨</span> Message
        </button>
        <button class="treat-editor-tab" data-tab="position">
          <span class="tab-icon">üìç</span> Position
        </button>
      </div>

      <div class="treat-editor-content">
        <!-- Message Tab -->
        <div class="treat-editor-section active" data-section="message">
          <textarea
            class="message-input"
            id="editor-message"
            placeholder="Write a message for others to discover..."
            maxlength="280"
          ></textarea>
          <div class="char-counter" id="editor-char-count">0 / 280</div>
        </div>

        <!-- Position Tab -->
        <div class="treat-editor-section" data-section="position">
          <div class="position-hint">
            <span class="hint-icon">üí°</span>
            <span>Click and drag the treat to reposition, or use buttons below</span>
          </div>
          <div class="position-controls">
            <button class="position-btn" id="editor-reposition-btn">
              <span class="btn-icon">üéØ</span> Drag to Move
            </button>
            <button class="position-btn" id="editor-reset-btn">
              <span class="btn-icon">‚Ü©Ô∏è</span> Reset
            </button>
          </div>
        </div>
      </div>

      <div class="treat-editor-actions">
        <button class="action-btn delete-btn" id="editor-delete-btn"><span>üóëÔ∏è</span> Delete</button>
        <button class="action-btn duplicate-btn" id="editor-duplicate-btn">
          <span>‚ßâ</span> Copy
        </button>
        <button class="action-btn save-btn" id="editor-save-btn"><span>‚úì</span> Save</button>
      </div>
    </div>

    <!-- Toast notification -->
    <div class="treat-editor-toast" id="editor-toast">Saved!</div>

    <!-- Proximity message indicator (explore mode) -->
    <div class="proximity-indicator" id="proximity-indicator">
      <span class="icon">üçæ</span>
      <div>
        <div class="text">Message nearby!</div>
        <div class="hint">Click or press E to read</div>
      </div>
    </div>

    <!-- Center screen reticle (explore mode) -->
    <div class="reticle" id="reticle"></div>

    <div class="info overlay" id="info">
      <h3 id="world-name">Loading...</h3>
      <p id="controls-hint">Click to look ‚Ä¢ WASD to move</p>
    </div>

    <!-- Admin Camera Calibration Panel -->
    <div class="admin-panel overlay" id="admin-panel">
      <h4>üéØ Camera Calibration</h4>

      <!-- Editable Position -->
      <div class="coord-group">
        <div class="coord-label">Position (x, y, z)</div>
        <div class="coord-inputs">
          <input type="number" id="admin-pos-x" step="0.1" value="0" />
          <input type="number" id="admin-pos-y" step="0.1" value="0" />
          <input type="number" id="admin-pos-z" step="0.1" value="0" />
        </div>
        <div class="coord-value">
          <span id="admin-pos">0.00, 0.00, 0.00</span>
          <button class="copy-btn" id="copy-pos">Copy</button>
        </div>
      </div>

      <!-- Editable Rotation -->
      <div class="coord-group">
        <div class="coord-label">Rotation (pitch, yaw)</div>
        <div class="coord-inputs">
          <input type="number" id="admin-rot-x" step="0.05" value="0" />
          <input type="number" id="admin-rot-y" step="0.05" value="0" />
        </div>
        <div class="coord-value">
          <span id="admin-rot">0.00, 0.00</span>
          <button class="copy-btn" id="copy-rot">Copy</button>
        </div>
      </div>

      <button class="apply-btn" id="apply-camera">‚ö° Apply Values</button>

      <div class="divider"></div>
      <div class="coord-group">
        <div class="coord-label">Camera Direction</div>
        <div class="coord-value">
          <span id="admin-dir">0.00, 0.00, 0.00</span>
          <button class="copy-btn" id="copy-dir">Copy</button>
        </div>
      </div>
      <div class="divider"></div>
      <button class="export-btn" id="export-config">üìã Copy startPosition</button>
      <div class="divider"></div>
      <div class="hotkeys">
        <kbd>C</kbd> Copy position<br />
        <kbd>V</kbd> Copy full config<br />
        <kbd>R</kbd> Reset to origin
      </div>
    </div>
    <div class="admin-toast" id="admin-toast">Copied!</div>

    <!-- Mobile joystick -->
    <div id="joystick-zone">
      <div id="joystick-base"></div>
      <div id="joystick-stick"></div>
    </div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.178.0/build/three.module.js",
          "@sparkjsdev/spark": "https://cdn.jsdelivr.net/npm/@sparkjsdev/spark@0.1.10/dist/spark.module.js"
        }
      }
    </script>

    <script type="module">
      import * as THREE from 'three';
      import { SplatMesh, SplatLoader, dyno } from '@sparkjsdev/spark';

      // ============================================
      // Deep Meditation Load-In Effect
      // ============================================

      // Animation time for shader effects
      const animateT = dyno.dynoFloat(0);
      const loadInProgress = dyno.dynoFloat(0); // 0 = effect active, 1 = fully loaded

      /**
       * Applies the Deep Meditation shader effect during world load-in.
       * Creates a mesmerizing fractal visualization that fades to normal view.
       */
      function applyLoadInEffect(mesh) {
        mesh.objectModifier = dyno.dynoBlock(
          { gsplat: dyno.Gsplat },
          { gsplat: dyno.Gsplat },
          ({ gsplat }) => {
            const d = new dyno.Dyno({
              inTypes: {
                gsplat: dyno.Gsplat,
                t: 'float',
                progress: 'float',
              },
              outTypes: { gsplat: dyno.Gsplat },
              globals: () => [
                dyno.unindent(`
                // Deep Meditation fractal effect
                vec4 fractal2(vec3 center, vec3 scales, vec4 rgba, float t, float intensity) {
                  vec3 pos = center;
                  float splatSize = length(scales);
                  vec3 p = pos * 0.65;
                  pos.y += 2.0;
                  float c = 0.0;
                  float l, l2 = length(p);
                  float m = 100.0;
                  
                  for (int i = 0; i < 10; i++) {
                    p.xyz = abs(p.xyz) / dot(p.xyz, p.xyz) - 0.8;
                    l = length(p.xyz);
                    c += exp(-1.0 * abs(l - l2) * (1.0 + sin(t * 1.5 + pos.y)));
                    l2 = length(p.xyz);
                    m = min(m, length(p.xyz));
                  }
                  
                  c = smoothstep(0.3, 0.5, m + sin(t * 1.5 + pos.y * 0.5)) + c * 0.1;              
                  return vec4(vec3(length(rgba.rgb)) * vec3(c, c*c, c*c*c) * intensity, 
                            rgba.a * exp(-20.0 * splatSize) * m * intensity);
                }

                // Gentle breathing animation
                vec3 breathAnimation(vec3 pos, float t, float intensity) {
                  float b = sin(t * 1.5) * intensity;
                  pos.y += 1.2;
                  pos *= 1.0 + exp(-3.0 * length(pos)) * b * 0.3;
                  pos.y -= 1.2;
                  return pos;
                }
              `),
              ],
              statements: ({ inputs, outputs }) =>
                dyno.unindentLines(`
              ${outputs.gsplat} = ${inputs.gsplat};
              
              vec3 localPos = ${inputs.gsplat}.center;
              vec3 splatScales = ${inputs.gsplat}.scales;
              vec4 splatColor = ${inputs.gsplat}.rgba;
              
              // Calculate effect intensity (fades out as progress approaches 1)
              float effectIntensity = 1.0 - ${inputs.progress};
              effectIntensity = effectIntensity * effectIntensity; // Ease out
              
              if (effectIntensity > 0.01) {
                // Apply Deep Meditation fractal coloring
                vec4 effectColor = fractal2(localPos, splatScales, splatColor, ${inputs.t}, effectIntensity);
                ${outputs.gsplat}.rgba = mix(splatColor, effectColor, effectIntensity * 0.8);
                
                // Apply subtle breathing animation
                ${outputs.gsplat}.center = breathAnimation(localPos, ${inputs.t}, effectIntensity);
              }
            `),
            });

            gsplat = d.apply({
              gsplat,
              t: animateT,
              progress: loadInProgress,
            }).gsplat;

            return { gsplat };
          }
        );

        mesh.updateGenerator();
      }

      // ============================================
      // GhostPreview - Semi-transparent preview mesh
      // ============================================

      /**
       * Creates a GhostPreview for showing a semi-transparent preview of a treat
       * before placement is confirmed.
       *
       * Features:
       * - 50% opacity for distinction from placed treats
       * - Real-time position updates from raycast hits
       * - Surface normal alignment
       * - Invalid state visualization (red tint when no valid surface)
       *
       * @param {THREE.Scene} scene - The Three.js scene to add the preview to
       * @returns {Object} GhostPreview interface
       */
      function createGhostPreview(scene) {
        const GHOST_OPACITY = 0.5;
        const INVALID_COLOR = new THREE.Color(0xff0000); // Red tint for invalid state
        const VALID_COLOR = new THREE.Color(0x88ccff); // Slight blue tint for valid state

        // State
        let previewMesh = null;
        let originalMaterials = new Map(); // Store original material colors for restoration
        let isVisible = false;
        let isValid = true;
        let currentRotationY = 0;
        let currentScale = 0.33;
        let loader = null;
        let cachedModelMinY = 0;

        /**
         * Initialize the GLTFLoader (lazy load from CDN)
         */
        async function initLoader() {
          if (loader) return loader;
          const { GLTFLoader } =
            await import('https://cdn.jsdelivr.net/npm/three@0.178.0/examples/jsm/loaders/GLTFLoader.js');
          loader = new GLTFLoader();
          return loader;
        }

        /**
         * Set all materials in a mesh to ghost opacity (50%)
         * Preserves glass material properties while adding ghost effect
         * @param {THREE.Object3D} mesh - The mesh to modify
         */
        function setGhostMaterials(mesh) {
          originalMaterials.clear();

          mesh.traverse((child) => {
            if (child.isMesh && child.material) {
              const materials = Array.isArray(child.material) ? child.material : [child.material];

              materials.forEach((mat, index) => {
                // Clone material to avoid affecting other instances
                const clonedMat = mat.clone();

                // Check if this is originally a glass/transparent material
                const isGlass =
                  mat.transparent ||
                  (mat.transmission && mat.transmission > 0) ||
                  (mat.opacity !== undefined && mat.opacity < 1);

                // Store original properties for restoration
                const key = `${child.uuid}-${index}`;
                originalMaterials.set(key, {
                  color: clonedMat.color ? clonedMat.color.clone() : null,
                  emissive: clonedMat.emissive ? clonedMat.emissive.clone() : null,
                  opacity: clonedMat.opacity,
                  transparent: clonedMat.transparent,
                  isGlass: isGlass,
                });

                // Set ghost properties
                clonedMat.transparent = true;
                clonedMat.depthWrite = false; // Prevent z-fighting with placed treats

                // For glass materials, use a higher opacity to keep them visible
                // For solid materials, use standard ghost opacity
                if (isGlass) {
                  // Glass ghost: slightly more transparent than original
                  clonedMat.opacity = Math.min(mat.opacity || 0.5, 0.7) * 0.8;
                } else {
                  clonedMat.opacity = GHOST_OPACITY;
                }

                // Apply slight blue tint for valid state
                if (clonedMat.color) {
                  clonedMat.color.lerp(VALID_COLOR, 0.2);
                }

                // Assign cloned material
                if (Array.isArray(child.material)) {
                  child.material[index] = clonedMat;
                } else {
                  child.material = clonedMat;
                }
              });
            }
          });
        }

        /**
         * Update material tint based on validity state
         * @param {boolean} valid - Whether the current position is valid
         */
        function updateMaterialTint(valid) {
          if (!previewMesh) return;

          const tintColor = valid ? VALID_COLOR : INVALID_COLOR;
          const tintStrength = valid ? 0.2 : 0.5; // Stronger red tint when invalid

          previewMesh.traverse((child) => {
            if (child.isMesh && child.material) {
              const materials = Array.isArray(child.material) ? child.material : [child.material];

              materials.forEach((mat, index) => {
                const key = `${child.uuid}-${index}`;
                const original = originalMaterials.get(key);

                if (original && original.color && mat.color) {
                  // Reset to original color then apply tint
                  mat.color.copy(original.color);
                  mat.color.lerp(tintColor, tintStrength);
                }
              });
            }
          });
        }

        /**
         * Orient mesh to align with a surface normal
         * @param {THREE.Object3D} mesh - The mesh to orient
         * @param {Object} normal - Surface normal {x, y, z}
         */
        function orientToNormal(mesh, normal) {
          const up = new THREE.Vector3(0, 1, 0);
          const normalVec = new THREE.Vector3(normal.x, normal.y, normal.z).normalize();

          // Create base quaternion from surface normal
          const baseQuaternion = new THREE.Quaternion();
          baseQuaternion.setFromUnitVectors(up, normalVec);

          // Apply Y-axis rotation on top of surface alignment
          const yRotation = new THREE.Quaternion();
          yRotation.setFromAxisAngle(normalVec, currentRotationY);

          // Combine: first align to surface, then rotate around surface normal
          mesh.quaternion.copy(baseQuaternion);
          mesh.quaternion.premultiply(yRotation);
        }

        return {
          /**
           * Load a GLB as the ghost preview
           * @param {string} glbUrl - URL to the GLB file
           * @returns {Promise<void>}
           */
          async load(glbUrl) {
            // Dispose previous preview
            this.dispose();

            const gltfLoader = await initLoader();

            return new Promise((resolve, reject) => {
              gltfLoader.load(
                glbUrl,
                (gltf) => {
                  previewMesh = gltf.scene.clone();

                  // Calculate bounding box for base offset
                  const boundingBox = new THREE.Box3().setFromObject(previewMesh);
                  cachedModelMinY = boundingBox.min.y;

                  // Set ghost materials (50% opacity)
                  setGhostMaterials(previewMesh);

                  // Set render order to render after splats but before solid treats
                  previewMesh.renderOrder = 0.5;
                  previewMesh.traverse((child) => {
                    if (child.isMesh) {
                      child.renderOrder = 0.5;
                    }
                  });

                  // Initially hidden
                  previewMesh.visible = false;
                  isVisible = false;
                  isValid = true;
                  currentRotationY = 0;
                  currentScale = 0.33;

                  // Add to scene
                  scene.add(previewMesh);

                  resolve();
                },
                undefined,
                (error) => {
                  reject(
                    new Error(`Failed to load ghost preview: ${error.message || 'Unknown error'}`)
                  );
                }
              );
            });
          },

          /**
           * Update position from raycast hit
           * @param {Object} hit - RaycastHit { position, normal, distance }
           * @param {Object} offset - Optional offset {x, y, z}
           */
          setPosition(hit, offset = { x: 0, y: 0, z: 0 }) {
            if (!previewMesh) return;

            // Apply current scale FIRST before calculating bounding box
            previewMesh.scale.setScalar(currentScale);

            // Orient to surface normal
            orientToNormal(previewMesh, hit.normal);

            // Recalculate base offset with current scale applied
            // The bounding box changes when scale changes, so we must recalculate
            const scaledBaseOffset = -cachedModelMinY * currentScale;
            const normalVec = new THREE.Vector3(
              hit.normal.x,
              hit.normal.y,
              hit.normal.z
            ).normalize();
            const offsetAlongNormal = normalVec.clone().multiplyScalar(scaledBaseOffset);

            // Apply position with offsets (user offset is also scaled)
            previewMesh.position.set(
              hit.position.x + offset.x * currentScale + offsetAlongNormal.x,
              hit.position.y + offset.y * currentScale + offsetAlongNormal.y,
              hit.position.z + offset.z * currentScale + offsetAlongNormal.z
            );
          },

          /**
           * Set validity state (affects visibility and tint)
           * @param {boolean} valid - Whether the current position is valid
           */
          setValid(valid) {
            if (isValid === valid) return;
            isValid = valid;
            updateMaterialTint(valid);
          },

          /**
           * Show the ghost preview
           */
          show() {
            if (previewMesh) {
              previewMesh.visible = true;
              isVisible = true;
            }
          },

          /**
           * Hide the ghost preview
           */
          hide() {
            if (previewMesh) {
              previewMesh.visible = false;
              isVisible = false;
            }
          },

          /**
           * Check if the ghost preview is visible
           * @returns {boolean}
           */
          isVisible() {
            return isVisible && previewMesh !== null;
          },

          /**
           * Check if the ghost preview is in a valid state
           * @returns {boolean}
           */
          isValidState() {
            return isValid;
          },

          /**
           * Set Y-axis rotation (in radians)
           * @param {number} radians - Rotation angle
           */
          setRotationY(radians) {
            currentRotationY = radians;
            // Rotation will be applied on next setPosition call
          },

          /**
           * Get current Y-axis rotation
           * @returns {number} Rotation in radians
           */
          getRotationY() {
            return currentRotationY;
          },

          /**
           * Set uniform scale
           * Note: Position recalculation happens in setPosition() which is called
           * on every mouse move, so the base offset will be correctly updated.
           * @param {number} scale - Scale factor
           */
          setScale(scale) {
            currentScale = Math.max(0.1, Math.min(5.0, scale)); // Clamp to bounds
            // Scale is applied in setPosition() to ensure base offset is recalculated
          },

          /**
           * Get current scale
           * @returns {number}
           */
          getScale() {
            return currentScale;
          },

          /**
           * Get current transform for placement
           * @returns {Object|null} { position, rotation, scale } or null if no preview
           */
          getTransform() {
            if (!previewMesh) return null;

            return {
              position: {
                x: previewMesh.position.x,
                y: previewMesh.position.y,
                z: previewMesh.position.z,
              },
              rotation: {
                x: previewMesh.rotation.x,
                y: previewMesh.rotation.y,
                z: previewMesh.rotation.z,
                order: previewMesh.rotation.order,
              },
              scale: {
                x: previewMesh.scale.x,
                y: previewMesh.scale.y,
                z: previewMesh.scale.z,
              },
            };
          },

          /**
           * Get the preview mesh (for advanced use)
           * @returns {THREE.Object3D|null}
           */
          getMesh() {
            return previewMesh;
          },

          /**
           * Get the ghost opacity value
           * @returns {number}
           */
          getOpacity() {
            return GHOST_OPACITY;
          },

          /**
           * Check if a mesh has ghost opacity applied
           * @returns {boolean}
           */
          hasGhostOpacity() {
            if (!previewMesh) return false;

            let hasCorrectOpacity = true;
            previewMesh.traverse((child) => {
              if (child.isMesh && child.material) {
                const materials = Array.isArray(child.material) ? child.material : [child.material];
                materials.forEach((mat) => {
                  if (mat.opacity !== GHOST_OPACITY) {
                    hasCorrectOpacity = false;
                  }
                });
              }
            });
            return hasCorrectOpacity;
          },

          /**
           * Dispose resources
           */
          dispose() {
            if (previewMesh) {
              scene.remove(previewMesh);

              previewMesh.traverse((child) => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                  if (Array.isArray(child.material)) {
                    child.material.forEach((m) => m.dispose());
                  } else {
                    child.material.dispose();
                  }
                }
              });

              previewMesh = null;
            }

            originalMaterials.clear();
            isVisible = false;
            isValid = true;
            currentRotationY = 0;
            currentScale = 0.33;
            cachedModelMinY = 0;
          },
        };
      }

      // ============================================
      // RaycastSystem - Raycast against splat geometry
      // ============================================

      /**
       * Creates a RaycastSystem for performing raycasts against splat geometry.
       * Uses SparkJS built-in raycasting via Three.js Raycaster.
       *
       * @param {THREE.Camera} camera - The camera for screen-to-world conversion
       * @param {SplatMesh} splatMesh - The SparkJS SplatMesh to raycast against
       * @returns {Object} RaycastSystem interface
       */
      function createRaycastSystem(camera, splatMesh) {
        // Reusable objects to reduce GC pressure
        const raycaster = new THREE.Raycaster();
        const screenCoords = new THREE.Vector2();
        const tempOrigin = new THREE.Vector3();
        const tempDirection = new THREE.Vector3();

        /**
         * Convert a SparkJS/Three.js intersection to our RaycastHit format.
         * @param {Object} intersection - Three.js intersection result
         * @returns {Object|null} RaycastHit or null
         */
        function toRaycastHit(intersection) {
          if (!intersection) return null;

          // Extract position from intersection point
          const position = {
            x: intersection.point.x,
            y: intersection.point.y,
            z: intersection.point.z,
          };

          // Extract normal - SparkJS provides face normal or we compute from geometry
          // Default to up vector if normal not available
          let normal = { x: 0, y: 1, z: 0 };
          if (intersection.face && intersection.face.normal) {
            normal = {
              x: intersection.face.normal.x,
              y: intersection.face.normal.y,
              z: intersection.face.normal.z,
            };
          } else if (intersection.normal) {
            // Some SparkJS versions provide normal directly
            normal = {
              x: intersection.normal.x,
              y: intersection.normal.y,
              z: intersection.normal.z,
            };
          }

          return {
            position,
            normal,
            distance: intersection.distance,
          };
        }

        return {
          /**
           * Perform raycast from normalized screen coordinates.
           * @param {number} x - Normalized x (-1 to 1, left to right)
           * @param {number} y - Normalized y (-1 to 1, bottom to top)
           * @returns {Object|null} RaycastHit or null
           */
          raycastFromScreen(x, y) {
            screenCoords.set(x, y);
            raycaster.setFromCamera(screenCoords, camera);

            // Raycast against the splat mesh
            const intersections = raycaster.intersectObject(splatMesh, false);

            if (intersections.length > 0) {
              return toRaycastHit(intersections[0]);
            }
            return null;
          },

          /**
           * Perform raycast from world ray.
           * @param {Object} origin - Ray origin {x, y, z}
           * @param {Object} direction - Ray direction {x, y, z} (should be normalized)
           * @returns {Object|null} RaycastHit or null
           */
          raycastFromRay(origin, direction) {
            tempOrigin.set(origin.x, origin.y, origin.z);
            tempDirection.set(direction.x, direction.y, direction.z).normalize();

            raycaster.set(tempOrigin, tempDirection);

            const intersections = raycaster.intersectObject(splatMesh, false);

            if (intersections.length > 0) {
              return toRaycastHit(intersections[0]);
            }
            return null;
          },

          /**
           * Perform raycast from mouse/touch event coordinates.
           * Convenience method that handles coordinate conversion.
           * @param {number} clientX - Client X from event
           * @param {number} clientY - Client Y from event
           * @param {HTMLCanvasElement} canvas - Canvas element for bounds
           * @returns {Object|null} RaycastHit or null
           */
          raycastFromEvent(clientX, clientY, canvas) {
            const rect = canvas.getBoundingClientRect();
            // Convert to normalized device coordinates (-1 to 1)
            const x = ((clientX - rect.left) / rect.width) * 2 - 1;
            const y = -((clientY - rect.top) / rect.height) * 2 + 1;

            return this.raycastFromScreen(x, y);
          },

          /**
           * Get the underlying Three.js Raycaster for advanced use.
           * @returns {THREE.Raycaster}
           */
          getRaycaster() {
            return raycaster;
          },
        };
      }

      // ============================================
      // TreatManager - GLB loading and placement
      // ============================================

      /**
       * Creates a TreatManager for loading, placing, and managing treats.
       * Uses Three.js GLTFLoader for GLB loading.
       *
       * @param {THREE.Scene} scene - The Three.js scene to add treats to
       * @returns {Object} TreatManager interface
       */
      function createTreatManager(scene) {
        // Import GLTFLoader dynamically
        const GLTFLoader = THREE.GLTFLoader || null;
        let loader = null;

        // State
        const treats = new Map(); // id -> { treat, mesh }
        let selectedGlbUrl = null;
        let selectedType = 'custom';
        let preloadedModel = null;
        let cachedModelMinY = 0; // Cached bounding box min Y for base offset calculation
        let pendingMetadata = {};
        let pendingOffset = { x: 0, y: 0, z: 0 }; // Position offset for models with off-center pivots
        const listeners = {
          treatPlaced: new Set(),
          treatRemoved: new Set(),
          treatClicked: new Set(),
          selectionChanged: new Set(),
          loadError: new Set(),
        };

        /**
         * Generate a unique ID for treats
         */
        function generateId() {
          return 'treat-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
        }

        /**
         * Initialize the GLTFLoader (lazy load from CDN)
         */
        async function initLoader() {
          if (loader) return loader;

          // Import GLTFLoader from Three.js examples
          const { GLTFLoader: LoaderClass } =
            await import('https://cdn.jsdelivr.net/npm/three@0.178.0/examples/jsm/loaders/GLTFLoader.js');
          loader = new LoaderClass();
          return loader;
        }

        /**
         * Load a GLB model from URL
         * @param {string} url - URL to the GLB file
         * @returns {Promise<THREE.Group>} The loaded model
         */
        async function loadGLB(url) {
          const gltfLoader = await initLoader();

          return new Promise((resolve, reject) => {
            gltfLoader.load(
              url,
              (gltf) => {
                resolve(gltf.scene);
              },
              undefined,
              (error) => {
                reject(new Error(`Failed to load GLB: ${error.message || 'Unknown error'}`));
              }
            );
          });
        }

        /**
         * Orient a mesh to align with a surface normal
         * @param {THREE.Object3D} mesh - The mesh to orient
         * @param {Object} normal - Surface normal {x, y, z}
         */
        function orientToNormal(mesh, normal) {
          // Create a quaternion that rotates from up (0,1,0) to the normal
          const up = new THREE.Vector3(0, 1, 0);
          const normalVec = new THREE.Vector3(normal.x, normal.y, normal.z).normalize();

          // Use quaternion for smooth rotation
          const quaternion = new THREE.Quaternion();
          quaternion.setFromUnitVectors(up, normalVec);
          mesh.quaternion.copy(quaternion);
        }

        /**
         * Notify listeners of an event
         */
        function emit(event, data) {
          if (listeners[event]) {
            listeners[event].forEach((callback) => {
              try {
                callback(data);
              } catch (error) {
                console.error(`TreatManager: Error in ${event} callback:`, error);
              }
            });
          }
        }

        return {
          /**
           * Select a treat for placement by loading its GLB
           * @param {string} glbUrl - URL to the GLB file
           * @param {string} type - Type of treat ('custom', 'library', 'message-bottle', etc.)
           * @returns {Promise<void>}
           */
          async selectTreat(glbUrl, type = 'custom') {
            try {
              // Dispose previous preloaded model
              if (preloadedModel) {
                preloadedModel.traverse((child) => {
                  if (child.geometry) child.geometry.dispose();
                  if (child.material) {
                    if (Array.isArray(child.material)) {
                      child.material.forEach((m) => m.dispose());
                    } else {
                      child.material.dispose();
                    }
                  }
                });
                preloadedModel = null;
              }

              selectedGlbUrl = glbUrl;
              selectedType = type;

              // Preload the model
              preloadedModel = await loadGLB(glbUrl);

              // Enhance materials for proper glass/transparency rendering with splat mesh
              preloadedModel.traverse((child) => {
                if (child.isMesh && child.material) {
                  const materials = Array.isArray(child.material)
                    ? child.material
                    : [child.material];
                  materials.forEach((mat) => {
                    // Check if this is a glass/transparent material (from GLB)
                    // GLB glass materials typically have: transparent=true, or transmission > 0
                    const isGlass =
                      mat.transparent ||
                      (mat.transmission && mat.transmission > 0) ||
                      (mat.opacity !== undefined && mat.opacity < 1);

                    if (isGlass) {
                      // Ensure proper transparency rendering
                      mat.transparent = true;
                      mat.depthWrite = false; // Glass shouldn't write to depth buffer
                      mat.side = THREE.DoubleSide; // Render both sides of glass

                      // If material supports transmission (MeshPhysicalMaterial), enhance it
                      if (mat.isMeshPhysicalMaterial) {
                        // Boost transmission for better glass effect
                        mat.transmission = mat.transmission || 0.9;
                        mat.thickness = mat.thickness || 0.5;
                        mat.roughness = Math.min(mat.roughness || 0, 0.1);
                        mat.ior = mat.ior || 1.5; // Glass index of refraction
                      }
                    }
                  });
                }
              });

              // Cache bounding box min Y for base offset (avoids recalculating on each placement)
              const boundingBox = new THREE.Box3().setFromObject(preloadedModel);
              cachedModelMinY = boundingBox.min.y;

              emit('selectionChanged', { glbUrl, type, ready: true });
            } catch (error) {
              selectedGlbUrl = null;
              selectedType = 'custom';
              preloadedModel = null;
              emit('loadError', { glbUrl, error: error.message });
              throw error;
            }
          },

          /**
           * Set metadata to attach to the next placed treat
           * @param {Object} metadata - Metadata object { text?, behaviorCode?, objectId? }
           */
          setMetadata(metadata) {
            pendingMetadata = { ...metadata };
            // Enforce text length limit
            if (pendingMetadata.text && pendingMetadata.text.length > 280) {
              pendingMetadata.text = pendingMetadata.text.substring(0, 280);
            }
          },

          /**
           * Set position offset for the next placed treat.
           * Useful for models with off-center pivots (e.g., message in a bottle).
           * @param {Object} offset - Offset {x, y, z} to apply after placement
           */
          setOffset(offset) {
            pendingOffset = {
              x: offset.x || 0,
              y: offset.y || 0,
              z: offset.z || 0,
            };
          },

          /**
           * Get the current offset
           * @returns {Object} Current offset {x, y, z}
           */
          getOffset() {
            return { ...pendingOffset };
          },

          /**
           * Place the selected treat at a raycast hit position
           * @param {Object} hit - RaycastHit { position, normal, distance }
           * @param {Object} metadata - Optional metadata to override pending metadata
           * @returns {Object|null} The placed treat or null if no treat selected
           */
          placeTreat(hit, metadata = null) {
            if (!selectedGlbUrl || !preloadedModel) {
              console.warn('TreatManager: No treat selected for placement');
              return null;
            }

            // Clone the preloaded model
            const mesh = preloadedModel.clone();

            // Use cached bounding box min Y (computed once in selectTreat)
            // The base offset moves the model up so its bottom sits at origin
            const baseOffset = -cachedModelMinY;

            // First orient to surface normal
            orientToNormal(mesh, hit.normal);

            // Now offset along the surface normal direction (which is the model's new "up")
            // This ensures the base sits on the surface regardless of surface angle
            const normalVec = new THREE.Vector3(
              hit.normal.x,
              hit.normal.y,
              hit.normal.z
            ).normalize();
            const offsetAlongNormal = normalVec.multiplyScalar(baseOffset);

            // Position at hit point with base offset along normal and user offset applied
            const finalPos = {
              x: hit.position.x + pendingOffset.x + offsetAlongNormal.x,
              y: hit.position.y + pendingOffset.y + offsetAlongNormal.y,
              z: hit.position.z + pendingOffset.z + offsetAlongNormal.z,
            };
            mesh.position.set(finalPos.x, finalPos.y, finalPos.z);

            // Set render order so GLB renders after splat mesh for proper occlusion
            mesh.renderOrder = 1;
            mesh.traverse((child) => {
              if (child.isMesh) {
                child.renderOrder = 1;
              }
            });

            // Add to scene
            scene.add(mesh);

            // Create treat data
            const treatId = generateId();
            const treatMetadata = metadata || { ...pendingMetadata };

            // Enforce text length constraint
            if (treatMetadata.text && treatMetadata.text.length > 280) {
              treatMetadata.text = treatMetadata.text.substring(0, 280);
            }

            const treat = {
              id: treatId,
              type: selectedType,
              glbUrl: selectedGlbUrl,
              position: { x: finalPos.x, y: finalPos.y, z: finalPos.z },
              rotation: {
                x: mesh.rotation.x,
                y: mesh.rotation.y,
                z: mesh.rotation.z,
                order: mesh.rotation.order,
              },
              scale: { x: mesh.scale.x, y: mesh.scale.y, z: mesh.scale.z },
              metadata: treatMetadata,
              offset: { ...pendingOffset }, // Store the offset used
            };

            // Store treat and mesh reference
            treats.set(treatId, { treat, mesh });

            // Make mesh clickable by storing treat ID
            mesh.userData.treatId = treatId;
            mesh.userData.isTreat = true;

            emit('treatPlaced', treat);
            return treat;
          },

          /**
           * Place the selected treat at a specific transform (from ghost preview)
           * This places the treat at the exact ghost position with full opacity.
           * (Requirements 2.1, 2.2)
           *
           * @param {Object} transform - Transform { position, rotation, scale }
           * @param {Object} metadata - Optional metadata to override pending metadata
           * @returns {Object|null} The placed treat or null if no treat selected
           */
          placeTreatAtTransform(transform, metadata = null) {
            if (!selectedGlbUrl || !preloadedModel) {
              console.warn('TreatManager: No treat selected for placement');
              return null;
            }

            if (!transform || !transform.position) {
              console.warn('TreatManager: Invalid transform provided');
              return null;
            }

            // Clone the preloaded model
            const mesh = preloadedModel.clone();

            // Apply the exact transform from ghost preview (Requirement 2.1)
            mesh.position.set(transform.position.x, transform.position.y, transform.position.z);

            // Apply rotation if provided
            if (transform.rotation) {
              mesh.rotation.set(
                transform.rotation.x,
                transform.rotation.y,
                transform.rotation.z,
                transform.rotation.order || 'XYZ'
              );
            }

            // Apply scale if provided
            if (transform.scale) {
              mesh.scale.set(transform.scale.x, transform.scale.y, transform.scale.z);
            }

            // The mesh is cloned from preloadedModel which preserves original GLB materials.
            // We do NOT modify any material properties here - the GLB's original
            // transparency, opacity, and depthWrite settings are respected as-is.
            // Glass materials will remain transparent, solid materials remain solid.

            // Set render order so GLB renders after splat mesh for proper occlusion
            mesh.renderOrder = 1;
            mesh.traverse((child) => {
              if (child.isMesh) {
                child.renderOrder = 1;
              }
            });

            // Add to scene
            scene.add(mesh);

            // Create treat data
            const treatId = generateId();
            const treatMetadata = metadata || { ...pendingMetadata };

            // Enforce text length constraint
            if (treatMetadata.text && treatMetadata.text.length > 280) {
              treatMetadata.text = treatMetadata.text.substring(0, 280);
            }

            const treat = {
              id: treatId,
              type: selectedType,
              glbUrl: selectedGlbUrl,
              position: {
                x: transform.position.x,
                y: transform.position.y,
                z: transform.position.z,
              },
              rotation: transform.rotation
                ? {
                    x: transform.rotation.x,
                    y: transform.rotation.y,
                    z: transform.rotation.z,
                    order: transform.rotation.order || 'XYZ',
                  }
                : { x: 0, y: 0, z: 0, order: 'XYZ' },
              scale: transform.scale
                ? {
                    x: transform.scale.x,
                    y: transform.scale.y,
                    z: transform.scale.z,
                  }
                : { x: 1, y: 1, z: 1 },
              metadata: treatMetadata,
              offset: { ...pendingOffset },
            };

            // Store treat and mesh reference
            treats.set(treatId, { treat, mesh });

            // Make mesh clickable by storing treat ID
            mesh.userData.treatId = treatId;
            mesh.userData.isTreat = true;

            emit('treatPlaced', treat);
            return treat;
          },

          /**
           * Remove a placed treat
           * @param {string} treatId - ID of the treat to remove
           * @returns {boolean} True if treat was removed
           */
          removeTreat(treatId) {
            const entry = treats.get(treatId);
            if (!entry) return false;

            // Remove mesh from scene
            scene.remove(entry.mesh);

            // Dispose resources
            entry.mesh.traverse((child) => {
              if (child.geometry) child.geometry.dispose();
              if (child.material) {
                if (Array.isArray(child.material)) {
                  child.material.forEach((m) => m.dispose());
                } else {
                  child.material.dispose();
                }
              }
            });

            treats.delete(treatId);
            emit('treatRemoved', entry.treat);
            return true;
          },

          /**
           * Get a treat by ID
           * @param {string} treatId - ID of the treat
           * @returns {Object|null} The treat or null
           */
          getTreat(treatId) {
            const entry = treats.get(treatId);
            return entry ? entry.treat : null;
          },

          /**
           * Get all placed treats
           * @returns {Array} Array of all treats
           */
          getAllTreats() {
            return Array.from(treats.values()).map((entry) => entry.treat);
          },

          /**
           * Get the mesh for a treat (for raycasting)
           * @param {string} treatId - ID of the treat
           * @returns {THREE.Object3D|null} The mesh or null
           */
          getMesh(treatId) {
            const entry = treats.get(treatId);
            return entry ? entry.mesh : null;
          },

          /**
           * Get all treat meshes (for raycasting)
           * @returns {Array<THREE.Object3D>} Array of all treat meshes
           */
          getAllMeshes() {
            return Array.from(treats.values()).map((entry) => entry.mesh);
          },

          /**
           * Handle treat click interaction
           * @param {string} treatId - ID of the clicked treat
           */
          onTreatClick(treatId) {
            const treat = this.getTreat(treatId);
            if (treat) {
              emit('treatClicked', treat);
            }
          },

          /**
           * Update a placed treat's position (for drag-to-reposition)
           * Maintains surface normal alignment during repositioning.
           * (Requirements 3.3, 3.4)
           *
           * @param {string} treatId - ID of the treat to update
           * @param {Object} hit - RaycastHit { position, normal, distance }
           * @returns {boolean} True if position was updated
           */
          updateTreatPosition(treatId, hit) {
            const entry = treats.get(treatId);
            if (!entry) {
              console.warn('TreatManager: Cannot update position - treat not found:', treatId);
              return false;
            }

            const { treat, mesh } = entry;

            // Calculate base offset from the treat's stored offset
            // We need to recompute the bounding box offset for proper surface alignment
            const boundingBox = new THREE.Box3().setFromObject(mesh);
            const modelMinY = boundingBox.min.y - mesh.position.y; // Get local min Y
            const baseOffset = -modelMinY;

            // Orient to new surface normal (Requirement 3.4)
            orientToNormal(mesh, hit.normal);

            // Offset along the surface normal direction
            const normalVec = new THREE.Vector3(
              hit.normal.x,
              hit.normal.y,
              hit.normal.z
            ).normalize();
            const offsetAlongNormal = normalVec.clone().multiplyScalar(baseOffset);

            // Apply stored offset from original placement
            const storedOffset = treat.offset || { x: 0, y: 0, z: 0 };

            // Calculate final position
            const finalPos = {
              x: hit.position.x + storedOffset.x + offsetAlongNormal.x,
              y: hit.position.y + storedOffset.y + offsetAlongNormal.y,
              z: hit.position.z + storedOffset.z + offsetAlongNormal.z,
            };

            // Update mesh position
            mesh.position.set(finalPos.x, finalPos.y, finalPos.z);

            // Update treat data
            treat.position = { x: finalPos.x, y: finalPos.y, z: finalPos.z };
            treat.rotation = {
              x: mesh.rotation.x,
              y: mesh.rotation.y,
              z: mesh.rotation.z,
              order: mesh.rotation.order,
            };

            return true;
          },

          /**
           * Check if a treat is currently selected for placement
           * @returns {boolean}
           */
          hasSelection() {
            return selectedGlbUrl !== null && preloadedModel !== null;
          },

          /**
           * Get the currently selected treat info
           * @returns {Object|null} { glbUrl, type } or null
           */
          getSelection() {
            if (!selectedGlbUrl) return null;
            return { glbUrl: selectedGlbUrl, type: selectedType };
          },

          /**
           * Clear the current selection
           */
          clearSelection() {
            if (preloadedModel) {
              preloadedModel.traverse((child) => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                  if (Array.isArray(child.material)) {
                    child.material.forEach((m) => m.dispose());
                  } else {
                    child.material.dispose();
                  }
                }
              });
              preloadedModel = null;
            }
            selectedGlbUrl = null;
            selectedType = 'custom';
            cachedModelMinY = 0;
            pendingMetadata = {};
            emit('selectionChanged', { glbUrl: null, type: null, ready: false });
          },

          /**
           * Check if a treat is currently selected for placement
           * @returns {boolean} True if a treat is selected
           */
          hasSelectedTreat() {
            return selectedGlbUrl !== null && preloadedModel !== null;
          },

          /**
           * Subscribe to events
           * @param {string} event - Event name ('treatPlaced', 'treatRemoved', 'treatClicked', 'selectionChanged', 'loadError')
           * @param {Function} callback - Callback function
           * @returns {Function} Unsubscribe function
           */
          on(event, callback) {
            if (listeners[event]) {
              listeners[event].add(callback);
              return () => listeners[event].delete(callback);
            }
            return () => {};
          },

          /**
           * Dispose all resources
           */
          dispose() {
            // Remove all treats
            for (const [id] of treats) {
              this.removeTreat(id);
            }

            // Clear preloaded model
            this.clearSelection();

            // Clear listeners
            Object.values(listeners).forEach((set) => set.clear());
          },
        };
      }

      // ============================================
      // ModeManager - Edit/Explore mode management
      // ============================================

      /**
       * Creates a ModeManager for switching between Edit and Explore modes.
       * Defaults to 'explore' mode on load.
       * Emits events on mode change for UI updates.
       */
      function createModeManager() {
        let currentMode = 'explore';
        const listeners = new Set();

        function notifyListeners() {
          listeners.forEach((callback) => {
            try {
              callback(currentMode);
            } catch (error) {
              console.error('ModeManager: Error in mode change callback:', error);
            }
          });
        }

        return {
          getMode() {
            return currentMode;
          },
          setMode(mode) {
            if (mode !== currentMode) {
              currentMode = mode;
              notifyListeners();
            }
          },
          toggle() {
            currentMode = currentMode === 'explore' ? 'edit' : 'explore';
            notifyListeners();
          },
          onModeChange(callback) {
            listeners.add(callback);
            return () => listeners.delete(callback);
          },
          isEditMode() {
            return currentMode === 'edit';
          },
          isExploreMode() {
            return currentMode === 'explore';
          },
        };
      }

      // Initialize ModeManager
      const modeManager = createModeManager();

      // ============================================
      // SelectionManager - Treat selection and visual feedback
      // ============================================

      /**
       * Creates a SelectionManager for handling treat selection and visual feedback.
       * Tracks selected and hovered treat IDs, emits events, and manages visual effects.
       *
       * Features:
       * - Selection outline/glow effect (orange, pulsing)
       * - Hover highlighting (brightness increase)
       * - Click-to-select in edit mode
       * - Event emission for selection/deselection/hover
       *
       * @param {THREE.Scene} scene - The Three.js scene
       * @param {Object} treatManager - The TreatManager instance
       * @returns {Object} SelectionManager interface
       */
      function createSelectionManager(scene, treatManager) {
        // State
        let selectedTreatId = null;
        let hoveredTreatId = null;

        // Visual effect state
        const originalMaterials = new Map(); // treatId -> Map of original material properties
        const HOVER_BRIGHTNESS = 0.2; // 20% brightness increase on hover
        const SELECTION_EMISSIVE = new THREE.Color(0xff6600); // Orange glow
        const SELECTION_EMISSIVE_INTENSITY = 0.3;

        // Event listeners
        const listeners = {
          select: new Set(),
          deselect: new Set(),
          hover: new Set(),
        };

        /**
         * Emit an event to all registered listeners
         * @param {string} event - Event name
         * @param {*} data - Event data
         */
        function emit(event, data) {
          if (listeners[event]) {
            listeners[event].forEach((callback) => {
              try {
                callback(data);
              } catch (error) {
                console.error(`SelectionManager: Error in ${event} callback:`, error);
              }
            });
          }
        }

        /**
         * Store original material properties for a treat mesh
         * @param {string} treatId - The treat ID
         * @param {THREE.Object3D} mesh - The treat mesh
         */
        function storeOriginalMaterials(treatId, mesh) {
          if (originalMaterials.has(treatId)) return;

          const materialsMap = new Map();
          mesh.traverse((child) => {
            if (child.isMesh && child.material) {
              const materials = Array.isArray(child.material) ? child.material : [child.material];
              materials.forEach((mat, index) => {
                const key = `${child.uuid}-${index}`;
                // Detect if this is a glass/transparent material
                const isGlass =
                  mat.transparent ||
                  (mat.transmission && mat.transmission > 0) ||
                  (mat.opacity !== undefined && mat.opacity < 1);
                materialsMap.set(key, {
                  emissive: mat.emissive ? mat.emissive.clone() : null,
                  emissiveIntensity: mat.emissiveIntensity || 0,
                  color: mat.color ? mat.color.clone() : null,
                  isGlass: isGlass,
                  opacity: mat.opacity,
                  transparent: mat.transparent,
                });
              });
            }
          });
          originalMaterials.set(treatId, materialsMap);
        }

        /**
         * Restore original material properties for a treat mesh
         * @param {string} treatId - The treat ID
         * @param {THREE.Object3D} mesh - The treat mesh
         */
        function restoreOriginalMaterials(treatId, mesh) {
          const materialsMap = originalMaterials.get(treatId);
          if (!materialsMap) return;

          mesh.traverse((child) => {
            if (child.isMesh && child.material) {
              const materials = Array.isArray(child.material) ? child.material : [child.material];
              materials.forEach((mat, index) => {
                const key = `${child.uuid}-${index}`;
                const original = materialsMap.get(key);
                if (original) {
                  if (original.emissive && mat.emissive) {
                    mat.emissive.copy(original.emissive);
                  }
                  mat.emissiveIntensity = original.emissiveIntensity;
                  if (original.color && mat.color) {
                    mat.color.copy(original.color);
                  }
                  // Restore glass properties
                  if (original.isGlass) {
                    mat.transparent = original.transparent;
                    mat.opacity = original.opacity;
                  }
                }
              });
            }
          });
        }

        /**
         * Apply selection visual effect to a treat mesh
         * Orange outline with subtle pulsing glow
         * Preserves glass/transparent material properties (message bottle stays see-through)
         * @param {THREE.Object3D} mesh - The treat mesh
         */
        function applySelectionEffect(mesh) {
          mesh.traverse((child) => {
            if (child.isMesh && child.material) {
              const materials = Array.isArray(child.material) ? child.material : [child.material];
              materials.forEach((mat) => {
                // Add orange emissive glow for selection
                if (mat.emissive) {
                  mat.emissive.copy(SELECTION_EMISSIVE);
                  mat.emissiveIntensity = SELECTION_EMISSIVE_INTENSITY;
                }
                // NOTE: We do NOT modify transparent/opacity here
                // Glass materials (like message bottle) keep their original transparency
              });
            }
          });
        }

        /**
         * Apply hover visual effect to a treat mesh
         * Light highlight (brightness increase)
         * @param {THREE.Object3D} mesh - The treat mesh
         */
        function applyHoverEffect(mesh) {
          mesh.traverse((child) => {
            if (child.isMesh && child.material) {
              const materials = Array.isArray(child.material) ? child.material : [child.material];
              materials.forEach((mat) => {
                // Increase brightness by lerping color toward white
                if (mat.color) {
                  const brighterColor = mat.color.clone();
                  brighterColor.lerp(new THREE.Color(0xffffff), HOVER_BRIGHTNESS);
                  mat.color.copy(brighterColor);
                }
              });
            }
          });
        }

        /**
         * Remove hover effect from a treat mesh (restore to original or selection state)
         * @param {string} treatId - The treat ID
         * @param {THREE.Object3D} mesh - The treat mesh
         */
        function removeHoverEffect(treatId, mesh) {
          // Restore original materials first
          restoreOriginalMaterials(treatId, mesh);

          // If this treat is selected, reapply selection effect
          if (treatId === selectedTreatId) {
            applySelectionEffect(mesh);
          }
        }

        return {
          /**
           * Select a treat for adjustment
           * @param {string} treatId - ID of the treat to select
           */
          select(treatId) {
            // Deselect previous if different
            if (selectedTreatId && selectedTreatId !== treatId) {
              this.deselect();
            }

            if (selectedTreatId === treatId) return; // Already selected

            const mesh = treatManager.getMesh(treatId);
            if (!mesh) {
              console.warn('SelectionManager: Cannot select - treat mesh not found:', treatId);
              return;
            }

            // Store original materials before modifying
            storeOriginalMaterials(treatId, mesh);

            selectedTreatId = treatId;

            // Apply selection visual effect
            applySelectionEffect(mesh);

            // Emit select event
            const treat = treatManager.getTreat(treatId);
            emit('select', { treatId, treat });

            console.log('SelectionManager: Selected treat:', treatId);
          },

          /**
           * Deselect the currently selected treat
           */
          deselect() {
            if (!selectedTreatId) return;

            const previousId = selectedTreatId;
            const mesh = treatManager.getMesh(previousId);

            if (mesh) {
              // Restore original materials
              restoreOriginalMaterials(previousId, mesh);
            }

            selectedTreatId = null;

            // Emit deselect event
            emit('deselect', { treatId: previousId });

            console.log('SelectionManager: Deselected treat:', previousId);
          },

          /**
           * Get the currently selected treat ID
           * @returns {string|null} The selected treat ID or null
           */
          getSelected() {
            return selectedTreatId;
          },

          /**
           * Check if a specific treat is selected
           * @param {string} treatId - The treat ID to check
           * @returns {boolean} True if the treat is selected
           */
          isSelected(treatId) {
            return selectedTreatId === treatId;
          },

          /**
           * Set the hovered treat (for visual feedback)
           * @param {string|null} treatId - The treat ID being hovered, or null to clear
           */
          setHovered(treatId) {
            // Don't hover the selected treat (it already has selection effect)
            if (treatId === selectedTreatId) {
              treatId = null;
            }

            if (hoveredTreatId === treatId) return; // No change

            // Remove hover effect from previous
            if (hoveredTreatId) {
              const prevMesh = treatManager.getMesh(hoveredTreatId);
              if (prevMesh) {
                removeHoverEffect(hoveredTreatId, prevMesh);
              }
            }

            const previousHovered = hoveredTreatId;
            hoveredTreatId = treatId;

            // Apply hover effect to new
            if (hoveredTreatId) {
              const mesh = treatManager.getMesh(hoveredTreatId);
              if (mesh) {
                // Store original materials if not already stored
                storeOriginalMaterials(hoveredTreatId, mesh);
                applyHoverEffect(mesh);
              }
            }

            // Emit hover event
            emit('hover', { treatId: hoveredTreatId, previousTreatId: previousHovered });
          },

          /**
           * Get the currently hovered treat ID
           * @returns {string|null} The hovered treat ID or null
           */
          getHovered() {
            return hoveredTreatId;
          },

          /**
           * Update selection visual (call in render loop for animated effects)
           * Currently handles the pulsing glow animation via CSS
           */
          updateSelectionVisual() {
            // The pulsing effect is handled via emissive material
            // This method can be extended for more complex shader-based effects
          },

          /**
           * Update hover visual (call in render loop if needed)
           */
          updateHoverVisual() {
            // Currently static effect, can be extended for animated hover
          },

          /**
           * Subscribe to selection events
           * @param {string} event - Event name ('select', 'deselect', 'hover')
           * @param {Function} callback - Callback function
           * @returns {Function} Unsubscribe function
           */
          on(event, callback) {
            if (listeners[event]) {
              listeners[event].add(callback);
              return () => listeners[event].delete(callback);
            }
            return () => {};
          },

          /**
           * Clean up when a treat is removed
           * @param {string} treatId - The removed treat ID
           */
          onTreatRemoved(treatId) {
            // Clear stored materials
            originalMaterials.delete(treatId);

            // Deselect if this was the selected treat
            if (selectedTreatId === treatId) {
              selectedTreatId = null;
              emit('deselect', { treatId });
            }

            // Clear hover if this was the hovered treat
            if (hoveredTreatId === treatId) {
              hoveredTreatId = null;
            }
          },

          /**
           * Dispose all resources
           */
          dispose() {
            selectedTreatId = null;
            hoveredTreatId = null;
            originalMaterials.clear();
            Object.values(listeners).forEach((set) => set.clear());
          },
        };
      }

      // Configuration - easy to tweak
      const CONFIG = {
        moveSpeed: 3,
        lookSensitivity: 0.002,
        mobileLookSensitivity: 0.003,
        maxPitch: Math.PI / 2,
        defaultFov: 75,
        cameraHeight: 1.6,
        cameraDistance: 5,
        joystickMaxDist: 35,
        loadTimeout: 60000, // 60s for large SPZ files
      };

      // Get world from URL params
      const params = new URLSearchParams(window.location.search);
      const spzUrl =
        params.get('url') ||
        'https://huggingface.co/datasets/dylanebert/3dgs/resolve/main/bonsai/bonsai-7k-mini.spz';
      const worldName = params.get('name') || 'Splat World';
      const thumbnailUrl = params.get('thumb');
      const adminParam = params.get('admin');
      const isAdminMode = adminParam === 'true' || adminParam === 'debug';
      // Flip control: ?flip=1 or ?flip=true to flip, ?flip=0 or ?flip=false to not flip
      // Default: true (most SPZ files need flipping)
      const flipParam = params.get('flip');
      const shouldFlip = flipParam === null || flipParam === '1' || flipParam === 'true';
      console.log('üîÑ Flip SPZ:', shouldFlip, '(param:', flipParam, ')');

      // Scene ID for loading shared scenes
      const sceneIdParam = params.get('scene');
      let worldUrl = spzUrl; // Track the world URL for scene state

      // Default treat GLB filename (e.g., 'geomarker_animated.glb')
      const S3_BASE_URL = 'https://s3.amazonaws.com/worldmatica/';
      const defaultTreatFile = params.get('defaultTreat') || 'geomarker_animated.glb';
      const defaultTreatUrl = S3_BASE_URL + defaultTreatFile;

      // Set thumbnail as loading background if provided
      if (thumbnailUrl) {
        const loadingEl = document.getElementById('loading');
        loadingEl.style.backgroundImage = `url(${thumbnailUrl})`;
        console.log('üñºÔ∏è Thumbnail set:', thumbnailUrl);
      } else {
        console.log('üñºÔ∏è No thumbnail provided');
      }

      // Read startPosition from URL params (passed from config.ts)
      const startPos = {
        x: parseFloat(params.get('px')) || 0,
        y: parseFloat(params.get('py')) || CONFIG.cameraHeight,
        z: parseFloat(params.get('pz')) || CONFIG.cameraDistance,
      };
      const startRot = {
        x: parseFloat(params.get('rx')) || 0,
        y: parseFloat(params.get('ry')) || 0,
      };
      console.log('üìç Start position:', startPos, 'rotation:', startRot);

      document.getElementById('world-name').textContent = worldName;

      // Setup Three.js
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1a1a2e);

      const camera = new THREE.PerspectiveCamera(
        CONFIG.defaultFov,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(startPos.x, startPos.y, startPos.z);
      // Apply rotation using euler with YXZ order (pitch=x, yaw=y)
      const initEuler = new THREE.Euler(startRot.x, startRot.y, 0, 'YXZ');
      camera.quaternion.setFromEuler(initEuler);

      const renderer = new THREE.WebGLRenderer({
        antialias: false,
        logarithmicDepthBuffer: true, // Better depth precision for splat + GLB mixing
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);

      // Lighting
      scene.add(new THREE.AmbientLight(0xffffff, 0.5));
      const dirLight = new THREE.DirectionalLight(0xffffff, 1);
      dirLight.position.set(5, 10, 5);
      scene.add(dirLight);

      // Progress tracking UI elements
      const loadingEl = document.getElementById('loading');
      const progressBar = document.getElementById('progress-bar');
      const progressText = document.getElementById('progress-text');
      const loadingStatus = document.getElementById('loading-status');
      let loadHandled = false;

      const hideLoading = () => {
        if (loadHandled) return;
        loadHandled = true;
        progressBar.style.width = '100%';
        progressText.textContent = '100%';
        loadingStatus.textContent = 'Ready!';
        setTimeout(() => loadingEl.classList.add('hidden'), 200);
      };

      const showError = (message) => {
        if (loadHandled) return;
        loadHandled = true;
        loadingEl.innerHTML = `
        <p style="color: #ff6600;">${message}</p>
        <button onclick="window.location.href='/'" style="margin-top:1rem;padding:0.5rem 1rem;background:#8a2be2;color:white;border:none;border-radius:0.5rem;cursor:pointer;">
          Back to Worlds
        </button>
      `;
      };

      // Placeholders for systems initialized after splat loads
      let splatMesh = null;
      let raycastSystem = null;
      let treatManager = null;
      let ghostPreview = null;
      let selectionManager = null;

      // Load splat with progress tracking using SplatLoader
      const splatLoader = new SplatLoader();

      console.log('üîÑ Loading SPZ from:', spzUrl);

      // Test URL accessibility
      fetch(spzUrl, { method: 'HEAD' })
        .then((res) => console.log('üì° URL check:', res.ok ? 'accessible' : `error ${res.status}`))
        .catch((err) => console.log('üì° URL check failed:', err.message));

      splatLoader.load(
        spzUrl,
        // onLoad - called when PackedSplats is ready
        (packedSplats) => {
          console.log('‚úÖ PackedSplats received, building mesh...');
          loadingStatus.textContent = 'Building mesh...';
          progressBar.style.width = '95%';
          progressText.textContent = '95%';

          // Create SplatMesh from loaded data
          splatMesh = new SplatMesh({ packedSplats });
          if (shouldFlip) {
            splatMesh.rotation.x = Math.PI; // Flip - SPZ files are often upside down
          }
          splatMesh.renderOrder = 0;

          // Apply Deep Meditation shader effect during load-in
          applyLoadInEffect(splatMesh);

          scene.add(splatMesh);
          console.log('‚úÖ SplatMesh added to scene');

          // Initialize systems that depend on splatMesh
          raycastSystem = createRaycastSystem(camera, splatMesh);
          treatManager = createTreatManager(scene);
          ghostPreview = createGhostPreview(scene);
          selectionManager = createSelectionManager(scene, treatManager);

          // Setup event listeners now that treatManager exists
          setupTreatEventListeners();

          hideLoading();

          // Check for shared scene to load after everything is initialized
          checkAndLoadSharedScene();
        },
        // onProgress - called during download/decode
        (event) => {
          if (loadHandled) return;
          if (event.lengthComputable && event.total > 0) {
            const percent = Math.round((event.loaded / event.total) * 90); // Reserve 10% for mesh building
            progressBar.style.width = `${percent}%`;
            progressText.textContent = `${percent}%`;

            if (percent < 30) {
              loadingStatus.textContent = 'Downloading...';
            } else if (percent < 70) {
              loadingStatus.textContent = 'Decoding splats...';
            } else {
              loadingStatus.textContent = 'Processing...';
            }
          } else {
            // No progress info available, show indeterminate state
            console.log('üì• Loading... (no progress info)');
          }
        },
        // onError
        (error) => {
          console.error('‚ùå Splat load failed:', error);
          showError(`Failed to load world: ${error.message || error}`);
        }
      );

      // Fallback timeout for very large files
      setTimeout(() => {
        if (!loadHandled && !splatMesh) {
          console.error('‚è±Ô∏è Timeout reached. loadHandled:', loadHandled, 'splatMesh:', splatMesh);
          showError('Loading timed out - file may be too large or URL may be invalid');
        }
      }, CONFIG.loadTimeout);

      // ============================================
      // Admin Camera Calibration (only when ?admin=true)
      // ============================================
      const adminPanel = document.getElementById('admin-panel');
      const adminToast = document.getElementById('admin-toast');
      let pitch = startRot.x; // Track pitch for admin display (initialized from URL)
      let yaw = startRot.y; // Track yaw for admin display (initialized from URL)

      if (isAdminMode) {
        adminPanel.classList.add('visible');
        console.log('üéØ Admin mode enabled - Camera calibration active');

        const adminPosEl = document.getElementById('admin-pos');
        const adminRotEl = document.getElementById('admin-rot');
        const adminDirEl = document.getElementById('admin-dir');

        // Show toast notification
        function showAdminToast(message) {
          adminToast.textContent = message;
          adminToast.classList.add('visible');
          setTimeout(() => adminToast.classList.remove('visible'), 1500);
        }

        // Format number to 2 decimal places
        const fmt = (n) => n.toFixed(2);

        // Editable input elements
        const posXInput = document.getElementById('admin-pos-x');
        const posYInput = document.getElementById('admin-pos-y');
        const posZInput = document.getElementById('admin-pos-z');
        const rotXInput = document.getElementById('admin-rot-x');
        const rotYInput = document.getElementById('admin-rot-y');

        // Initialize inputs with current values
        posXInput.value = fmt(camera.position.x);
        posYInput.value = fmt(camera.position.y);
        posZInput.value = fmt(camera.position.z);
        rotXInput.value = fmt(pitch);
        rotYInput.value = fmt(yaw);

        // Update admin panel with current camera state
        function updateAdminPanel() {
          const pos = camera.position;
          const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);

          adminPosEl.textContent = `${fmt(pos.x)}, ${fmt(pos.y)}, ${fmt(pos.z)}`;
          adminRotEl.textContent = `${fmt(pitch)}, ${fmt(yaw)}`;
          adminDirEl.textContent = `${fmt(dir.x)}, ${fmt(dir.y)}, ${fmt(dir.z)}`;

          // Sync inputs with current values (only if not focused)
          if (document.activeElement !== posXInput) posXInput.value = fmt(pos.x);
          if (document.activeElement !== posYInput) posYInput.value = fmt(pos.y);
          if (document.activeElement !== posZInput) posZInput.value = fmt(pos.z);
          if (document.activeElement !== rotXInput) rotXInput.value = fmt(pitch);
          if (document.activeElement !== rotYInput) rotYInput.value = fmt(yaw);
        }

        // Apply camera values from inputs
        function applyCameraFromInputs() {
          const newX = parseFloat(posXInput.value) || 0;
          const newY = parseFloat(posYInput.value) || 0;
          const newZ = parseFloat(posZInput.value) || 0;
          const newPitch = parseFloat(rotXInput.value) || 0;
          const newYaw = parseFloat(rotYInput.value) || 0;

          camera.position.set(newX, newY, newZ);
          pitch = newPitch;
          yaw = newYaw;

          // Update camera quaternion using euler (YXZ order for FPS)
          const newEuler = new THREE.Euler(pitch, yaw, 0, 'YXZ');
          camera.quaternion.setFromEuler(newEuler);

          // Also update the global euler if it exists (for FPS controls sync)
          if (typeof euler !== 'undefined') {
            euler.x = pitch;
            euler.y = yaw;
          }

          updateAdminPanel();
        }

        // Apply button
        document.getElementById('apply-camera').addEventListener('click', applyCameraFromInputs);

        // Real-time update on input change (arrow keys, scroll, typing)
        [posXInput, posYInput, posZInput, rotXInput, rotYInput].forEach((input) => {
          input.addEventListener('input', applyCameraFromInputs);
          input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
              input.blur();
            }
          });
        });

        // Get config object for export (matches config.ts startPosition format)
        function getConfigObject() {
          const pos = camera.position;
          return `startPosition: {
  position: { x: ${fmt(pos.x)}, y: ${fmt(pos.y)}, z: ${fmt(pos.z)} },
  rotation: { x: ${fmt(pitch)}, y: ${fmt(yaw)} },
},`;
        }

        // Copy to clipboard helper
        async function copyToClipboard(text, message) {
          try {
            await navigator.clipboard.writeText(text);
            showAdminToast(message);
          } catch (err) {
            console.error('Failed to copy:', err);
            showAdminToast('Copy failed!');
          }
        }

        // Copy position button
        document.getElementById('copy-pos').addEventListener('click', () => {
          const pos = camera.position;
          copyToClipboard(
            `{ x: ${fmt(pos.x)}, y: ${fmt(pos.y)}, z: ${fmt(pos.z)} }`,
            'Position copied!'
          );
        });

        // Copy rotation button
        document.getElementById('copy-rot').addEventListener('click', () => {
          copyToClipboard(`{ pitch: ${fmt(pitch)}, yaw: ${fmt(yaw)} }`, 'Rotation copied!');
        });

        // Copy direction button
        document.getElementById('copy-dir').addEventListener('click', () => {
          const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
          copyToClipboard(
            `{ x: ${fmt(dir.x)}, y: ${fmt(dir.y)}, z: ${fmt(dir.z)} }`,
            'Direction copied!'
          );
        });

        // Export full config button
        document.getElementById('export-config').addEventListener('click', () => {
          copyToClipboard(getConfigObject(), 'startPosition copied!');
        });

        // Keyboard shortcuts for admin
        window.addEventListener('keydown', (e) => {
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

          if (e.key === 'c' || e.key === 'C') {
            const pos = camera.position;
            copyToClipboard(
              `{ x: ${fmt(pos.x)}, y: ${fmt(pos.y)}, z: ${fmt(pos.z)} }`,
              'Position copied!'
            );
          } else if (e.key === 'v' || e.key === 'V') {
            copyToClipboard(getConfigObject(), 'startPosition copied!');
          } else if (e.key === 'r' || e.key === 'R') {
            camera.position.set(0, CONFIG.cameraHeight, CONFIG.cameraDistance);
            pitch = 0;
            yaw = 0;
            camera.rotation.set(0, 0, 0);
            showAdminToast('Reset to origin!');
          }
        });

        // Update panel on animation frame
        window.adminUpdatePanel = updateAdminPanel;
      }
      // Resize handler
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Detect mobile
      const isMobile =
        /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
          navigator.userAgent
        ) || 'ontouchstart' in window;

      // Setup UI for mobile/desktop
      const infoEl = document.getElementById('info');
      const controlsHint = document.getElementById('controls-hint');
      const joystickZone = document.getElementById('joystick-zone');
      const joystickStick = document.getElementById('joystick-stick');

      if (isMobile) {
        infoEl.classList.add('mobile');
        controlsHint.textContent = 'Drag to look ‚Ä¢ Joystick to move ‚Ä¢ Tap messages';
        joystickZone.classList.add('visible');
      }

      // ============================================
      // Mode Toggle UI
      // ============================================

      const modeToggleBtn = document.getElementById('mode-toggle');
      const modeLabelEl = document.getElementById('mode-label');
      const modeBadgeEl = document.getElementById('mode-badge');

      // Update UI when mode changes
      modeManager.onModeChange((mode) => {
        const isEdit = mode === 'edit';

        // Update toggle button
        modeToggleBtn.dataset.mode = mode;
        modeLabelEl.textContent = isEdit ? 'Edit' : 'Explore';
        modeToggleBtn.querySelector('.icon').textContent = isEdit ? '‚úèÔ∏è' : 'üëÅÔ∏è';

        // Show mode badge briefly
        modeBadgeEl.textContent = isEdit ? 'Edit Mode' : 'Explore Mode';
        modeBadgeEl.classList.add('visible');
        setTimeout(() => modeBadgeEl.classList.remove('visible'), 1500);

        // Update controls hint
        if (isEdit) {
          controlsHint.textContent = isMobile
            ? 'Tap to place ‚Ä¢ Drag to look ‚Ä¢ Joystick to move'
            : 'Click to place ‚Ä¢ ESC to look ‚Ä¢ WASD to move';
        } else {
          controlsHint.textContent = isMobile
            ? 'Drag to look ‚Ä¢ Joystick to move ‚Ä¢ Tap messages'
            : 'Click to look ‚Ä¢ WASD to move ‚Ä¢ E to read messages';
        }
      });

      // Toggle mode on button click
      modeToggleBtn.addEventListener('click', () => {
        modeManager.toggle();
      });

      // Keyboard shortcut: Tab to toggle mode
      document.addEventListener('keydown', (e) => {
        if (e.code === 'Tab') {
          e.preventDefault();
          modeManager.toggle();
        }
      });

      // ============================================
      // Treat Panel UI
      // ============================================

      const treatPanelEl = document.getElementById('treat-panel');
      const treatStatusEl = document.getElementById('treat-status');
      const glbUrlInput = document.getElementById('glb-url');
      const treatTextInput = document.getElementById('treat-text');
      const charCountEl = document.getElementById('char-count');
      const loadTreatBtn = document.getElementById('load-treat-btn');
      const presetGeomarkerBtn = document.getElementById('preset-geomarker');
      const presetBottleBtn = document.getElementById('preset-bottle');
      const placedTreatsSection = document.getElementById('placed-treats-section');

      // Set geomarker button URL from query param (allows config.ts to control default treat)
      if (presetGeomarkerBtn) {
        presetGeomarkerBtn.dataset.url = defaultTreatUrl;
      }
      const placedTreatsList = document.getElementById('placed-treats-list');
      const messageModal = document.getElementById('message-modal');
      const messageContent = document.getElementById('message-content');
      const closeModalBtn = document.getElementById('close-modal-btn');
      const offsetXInput = document.getElementById('offset-x');
      const offsetYInput = document.getElementById('offset-y');
      const offsetZInput = document.getElementById('offset-z');
      const cancelPlacementBtn = document.getElementById('cancel-placement-btn');

      // Update offset when inputs change
      function updateOffset() {
        if (!treatManager) return;
        treatManager.setOffset({
          x: parseFloat(offsetXInput.value) || 0,
          y: parseFloat(offsetYInput.value) || 0,
          z: parseFloat(offsetZInput.value) || 0,
        });
      }
      offsetXInput.addEventListener('input', updateOffset);
      offsetYInput.addEventListener('input', updateOffset);
      offsetZInput.addEventListener('input', updateOffset);

      // Cancel placement button handler (Requirement 2.4)
      cancelPlacementBtn.addEventListener('click', () => {
        exitPlacementMode();
        if (treatManager) treatManager.clearSelection();
        // Clear preset selections
        document.querySelectorAll('.preset-btn').forEach((btn) => btn.classList.remove('selected'));
        showStatus('Placement cancelled', 'ready');
        setTimeout(hideStatus, 1500);
      });

      // Show/hide treat panel based on mode
      // Auto-load geomarker as default treat when entering edit mode
      modeManager.onModeChange(async (mode) => {
        if (mode === 'edit') {
          treatPanelEl.classList.add('visible');
          // Auto-load geomarker as default treat for enterprise annotation
          // Use setTimeout to ensure treatManager is initialized after splat loads
          setTimeout(() => {
            if (treatManager && presetGeomarkerBtn && !treatManager.hasSelectedTreat()) {
              console.log('Auto-loading default geomarker treat');
              presetGeomarkerBtn.click();
            }
          }, 100);
        } else {
          treatPanelEl.classList.remove('visible');
        }
      });

      // Character count for text input
      treatTextInput.addEventListener('input', () => {
        const len = treatTextInput.value.length;
        charCountEl.textContent = `${len} / 280`;
        charCountEl.classList.remove('warning', 'error');
        if (len > 250) charCountEl.classList.add('warning');
        if (len >= 280) charCountEl.classList.add('error');

        // Update pending metadata
        if (treatManager) treatManager.setMetadata({ text: treatTextInput.value || undefined });
      });

      // Status display helper
      function showStatus(message, type = 'ready') {
        treatStatusEl.textContent = message;
        treatStatusEl.className = `status ${type}`;
        treatStatusEl.style.display = 'block';
      }

      function hideStatus() {
        treatStatusEl.style.display = 'none';
      }

      // Generic preset button handler
      async function handlePresetClick(btn, treatId, displayName, offsetY = 0) {
        if (!treatManager) {
          showStatus('World still loading...', 'loading');
          return;
        }
        const url = btn.dataset.url;
        glbUrlInput.value = url;

        // Clear other preset selections
        document.querySelectorAll('.preset-btn').forEach((b) => b.classList.remove('selected'));
        btn.classList.add('selected');

        // Set default offset
        offsetXInput.value = '0';
        offsetYInput.value = String(offsetY);
        offsetZInput.value = '0';
        updateOffset();

        showStatus(`Loading ${displayName}...`, 'loading');

        try {
          await treatManager.selectTreat(url, treatId);
          // Load ghost preview for the selected treat
          if (ghostPreview) {
            await ghostPreview.load(url);
            ghostPreview.show();
            enterPlacementMode();
          }
          showStatus('‚úì Ready to place! Move cursor to preview.', 'ready');
        } catch (error) {
          showStatus(`‚úó ${error.message}`, 'error');
        }
      }

      // Geomarker preset (default for enterprise annotation)
      presetGeomarkerBtn.addEventListener('click', () => {
        handlePresetClick(presetGeomarkerBtn, 'geomarker', 'Geomarker Pin', 0);
      });

      // Message in a Bottle preset
      presetBottleBtn.addEventListener('click', () => {
        handlePresetClick(presetBottleBtn, 'message-bottle', 'Message in a Bottle', 0.1);
      });

      // Load custom GLB button
      loadTreatBtn.addEventListener('click', async () => {
        if (!treatManager) {
          showStatus('World still loading...', 'loading');
          return;
        }
        const url = glbUrlInput.value.trim();
        if (!url) {
          showStatus('Please enter a GLB URL', 'error');
          return;
        }

        // Clear preset selections
        document.querySelectorAll('.preset-btn').forEach((btn) => btn.classList.remove('selected'));

        showStatus('Loading GLB...', 'loading');
        loadTreatBtn.disabled = true;

        try {
          await treatManager.selectTreat(url, 'custom');
          // Load ghost preview for the selected treat
          if (ghostPreview) {
            await ghostPreview.load(url);
            ghostPreview.show();
            enterPlacementMode();
          }
          showStatus('‚úì Ready to place! Move cursor to preview.', 'ready');
        } catch (error) {
          showStatus(`‚úó ${error.message}`, 'error');
        } finally {
          loadTreatBtn.disabled = false;
        }
      });

      // Update placed treats list
      function updatePlacedTreatsList() {
        if (!treatManager) {
          placedTreatsSection.style.display = 'none';
          return;
        }
        const treats = treatManager.getAllTreats();

        if (treats.length === 0) {
          placedTreatsSection.style.display = 'none';
          return;
        }

        placedTreatsSection.style.display = 'block';
        placedTreatsList.innerHTML = treats
          .map((treat) => {
            const icon = treat.type === 'message-bottle' ? 'üçæ' : 'üìç';
            const hasMessage = treat.metadata && treat.metadata.text;
            // Show message preview (first 25 chars) or type name
            let displayText;
            if (hasMessage) {
              const preview = treat.metadata.text.substring(0, 25);
              displayText = preview + (treat.metadata.text.length > 25 ? '...' : '');
            } else {
              displayText = treat.type === 'message-bottle' ? 'Empty bottle' : 'Marker';
            }
            const isSelected = selectedPlacedTreatId === treat.id;
            return `
          <div class="treat-item ${isSelected ? 'selected' : ''}" data-id="${treat.id}" data-glb-url="${treat.glbUrl}" data-type="${treat.type}">
            <span class="treat-name" title="${hasMessage ? treat.metadata.text : ''}">${icon} ${displayText}</span>
            <div class="treat-actions">
              <button class="edit-btn" data-id="${treat.id}" title="Edit">‚úèÔ∏è</button>
              <button class="delete-btn" data-id="${treat.id}" title="Delete">‚úï</button>
            </div>
          </div>
        `;
          })
          .join('');
      }

      // Handle clicks in placed treats list (edit, delete, select)
      placedTreatsList.addEventListener('click', async (e) => {
        // Delete button
        if (e.target.classList.contains('delete-btn')) {
          const treatId = e.target.dataset.id;
          if (treatManager) treatManager.removeTreat(treatId);
          updatePlacedTreatsList();
          return;
        }

        // Edit button - select treat and show editor
        if (e.target.classList.contains('edit-btn')) {
          const treatId = e.target.dataset.id;
          if (treatId) {
            selectPlacedTreatForAdjustment(treatId);
            updatePlacedTreatsList();
          }
          return;
        }

        // Click on treat name or item - select it
        const treatItem = e.target.closest('.treat-item');
        if (treatItem && !e.target.classList.contains('delete-btn')) {
          const treatId = treatItem.dataset.id;
          if (treatId) {
            selectPlacedTreatForAdjustment(treatId);
            updatePlacedTreatsList();
          }
          return;
        }
      });

      // Setup treat event listeners (called after treatManager is initialized)
      function setupTreatEventListeners() {
        if (!treatManager) return;

        treatManager.on('treatPlaced', (treat) => {
          console.log('Treat placed:', treat);
          updatePlacedTreatsList();
        });

        treatManager.on('treatRemoved', (treat) => {
          console.log('Treat removed:', treat);
          updatePlacedTreatsList();
          // Notify selectionManager when a treat is removed
          if (selectionManager) {
            selectionManager.onTreatRemoved(treat.id);
          }
        });

        treatManager.on('treatClicked', (treat) => {
          console.log('Treat clicked:', treat);
          // In edit mode, select the treat for adjustment (Requirement 3.1)
          if (modeManager.isEditMode() && selectionManager && !isInPlacementMode) {
            selectionManager.select(treat.id);
          } else if (treat.metadata && treat.metadata.text) {
            // In explore mode or if not in edit mode, show message
            showMessageModal(treat.metadata.text);
          }
        });

        // Setup selectionManager event listeners
        if (selectionManager) {
          selectionManager.on('select', ({ treatId, treat }) => {
            console.log('SelectionManager: Treat selected for adjustment:', treatId);
          });

          selectionManager.on('deselect', ({ treatId }) => {
            console.log('SelectionManager: Treat deselected:', treatId);
          });
        }
      }

      // ============================================
      // Treat Click Interaction (Message Display)
      // ============================================

      // Raycaster for treat clicking
      const treatRaycaster = new THREE.Raycaster();
      const treatScreenCoords = new THREE.Vector2();

      function raycastTreats(clientX, clientY) {
        if (!treatManager) return null;

        const rect = renderer.domElement.getBoundingClientRect();
        treatScreenCoords.x = ((clientX - rect.left) / rect.width) * 2 - 1;
        treatScreenCoords.y = -((clientY - rect.top) / rect.height) * 2 + 1;

        treatRaycaster.setFromCamera(treatScreenCoords, camera);

        const meshes = treatManager.getAllMeshes();
        if (meshes.length === 0) return null;

        const intersections = treatRaycaster.intersectObjects(meshes, true);

        if (intersections.length > 0) {
          // Find the treat ID from the intersected object or its parents
          let obj = intersections[0].object;
          while (obj) {
            if (obj.userData && obj.userData.treatId) {
              return obj.userData.treatId;
            }
            obj = obj.parent;
          }
        }
        return null;
      }

      // Show message modal
      function showMessageModal(text) {
        messageContent.textContent = text;
        messageModal.classList.add('visible');
      }

      // Close message modal
      closeModalBtn.addEventListener('click', () => {
        messageModal.classList.remove('visible');
      });

      messageModal.addEventListener('click', (e) => {
        if (e.target === messageModal) {
          messageModal.classList.remove('visible');
        }
      });

      // FPS Controls
      const moveState = { forward: false, backward: false, left: false, right: false };
      const joystickInput = { x: 0, y: 0 };
      const euler = new THREE.Euler(startRot.x, startRot.y, 0, 'YXZ'); // Initialize from URL params
      let isLocked = false;

      // Key mapping for cleaner event handling
      const keyMap = {
        KeyW: 'forward',
        ArrowUp: 'forward',
        KeyS: 'backward',
        ArrowDown: 'backward',
        KeyA: 'left',
        ArrowLeft: 'left',
        KeyD: 'right',
        ArrowRight: 'right',
      };

      // Desktop keyboard controls
      document.addEventListener('keydown', (e) => {
        // Ignore movement keys when typing in input fields
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
        if (keyMap[e.code]) moveState[keyMap[e.code]] = true;
      });

      document.addEventListener('keyup', (e) => {
        // Ignore movement keys when typing in input fields
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
        if (keyMap[e.code]) moveState[keyMap[e.code]] = false;
      });

      // Visual feedback for raycast hits (temporary marker)
      let hitMarker = null;

      function createHitMarker() {
        const geometry = new THREE.SphereGeometry(0.05, 16, 16);
        const material = new THREE.MeshBasicMaterial({ color: 0xff6600 });
        const marker = new THREE.Mesh(geometry, material);
        marker.visible = false;
        scene.add(marker);
        return marker;
      }

      function showHitMarker(hit) {
        if (!hitMarker) hitMarker = createHitMarker();
        hitMarker.position.set(hit.position.x, hit.position.y, hit.position.z);
        hitMarker.visible = true;
        // Hide after 1 second
        setTimeout(() => {
          if (hitMarker) hitMarker.visible = false;
        }, 1000);
      }

      function showMissIndicator() {
        // Flash the treat panel border red briefly to indicate no valid surface
        const panel = document.getElementById('treat-panel');
        if (panel) {
          panel.style.borderColor = 'rgba(255, 0, 0, 0.8)';
          setTimeout(() => {
            panel.style.borderColor = 'rgba(138, 43, 226, 0.5)';
          }, 300);
        }
      }

      // ============================================
      // Surface Indicator Ring (shows where treat will be placed)
      // ============================================
      let surfaceRing = null;

      function createSurfaceRing() {
        const geometry = new THREE.RingGeometry(0.08, 0.12, 32);
        const material = new THREE.MeshBasicMaterial({
          color: 0xff6600,
          side: THREE.DoubleSide,
          transparent: true,
          opacity: 0.8,
          depthWrite: false,
        });
        const ring = new THREE.Mesh(geometry, material);
        ring.visible = false;
        ring.renderOrder = 2; // Render on top
        scene.add(ring);
        return ring;
      }

      function updateSurfaceRing(hit) {
        if (!surfaceRing) surfaceRing = createSurfaceRing();

        // Position at hit point
        surfaceRing.position.set(hit.position.x, hit.position.y, hit.position.z);

        // Orient to face along surface normal
        const normal = new THREE.Vector3(hit.normal.x, hit.normal.y, hit.normal.z);
        surfaceRing.lookAt(
          hit.position.x + normal.x,
          hit.position.y + normal.y,
          hit.position.z + normal.z
        );

        // Offset slightly along normal to prevent z-fighting
        surfaceRing.position.addScaledVector(normal, 0.01);

        surfaceRing.visible = true;
      }

      function hideSurfaceRing() {
        if (surfaceRing) surfaceRing.visible = false;
      }

      // ============================================
      // Placement Mode Management
      // ============================================
      let isInPlacementMode = false;
      let lastValidHit = null;
      let selectedPlacedTreatId = null; // Track selected treat for adjustment (Requirement 2.3, 3.1)

      // ============================================
      // Drag-to-Reposition State (Requirements 3.3, 3.4, 3.5)
      // ============================================
      let isDragging = false;
      let dragStartPosition = null; // Store initial position for potential undo
      let lastDragHit = null; // Track last valid drag position

      function enterPlacementMode() {
        isInPlacementMode = true;
        // Change cursor to crosshair (Requirement 6.1)
        renderer.domElement.style.cursor = 'crosshair';
        // Show cancel button (Requirement 2.4)
        if (cancelPlacementBtn) cancelPlacementBtn.style.display = 'block';
      }

      function exitPlacementMode() {
        isInPlacementMode = false;
        renderer.domElement.style.cursor = 'default';
        if (ghostPreview) ghostPreview.hide();
        hideSurfaceRing();
        lastValidHit = null;
        // Hide cancel button (Requirement 2.4)
        if (cancelPlacementBtn) cancelPlacementBtn.style.display = 'none';
      }

      /**
       * Select a placed treat for adjustment (Requirement 2.3, 3.1)
       * Uses SelectionManager for visual feedback (Requirement 3.2, 6.4)
       * @param {string} treatId - ID of the treat to select
       */
      function selectPlacedTreatForAdjustment(treatId) {
        selectedPlacedTreatId = treatId;

        // Use SelectionManager for visual feedback (orange outline, glow effect)
        if (selectionManager) {
          selectionManager.select(treatId);
        }

        window.dispatchEvent(
          new CustomEvent('treat-selected-for-adjustment', { detail: { treatId } })
        );
        console.log('Selected treat for adjustment:', treatId);
      }

      /**
       * Deselect the currently selected placed treat (Requirement 3.6)
       * Uses SelectionManager to remove visual feedback
       */
      function deselectPlacedTreat() {
        if (selectedPlacedTreatId) {
          const previousId = selectedPlacedTreatId;
          selectedPlacedTreatId = null;

          // Use SelectionManager to remove visual feedback
          if (selectionManager) {
            selectionManager.deselect();
          }

          window.dispatchEvent(
            new CustomEvent('treat-deselected', { detail: { treatId: previousId } })
          );
          console.log('Deselected treat:', previousId);
        }
      }

      /**
       * Get the currently selected placed treat ID
       * @returns {string|null} The selected treat ID or null
       */
      function getSelectedPlacedTreatId() {
        return selectedPlacedTreatId;
      }

      // ============================================
      // Drag-to-Reposition Functions (Requirements 3.3, 3.4, 3.5)
      // ============================================

      /**
       * Start dragging a selected treat (Requirement 3.3)
       * @param {number} clientX - Mouse X position
       * @param {number} clientY - Mouse Y position
       */
      function startDrag(clientX, clientY) {
        if (!selectedPlacedTreatId || !treatManager) return;

        const treat = treatManager.getTreat(selectedPlacedTreatId);
        if (!treat) return;

        isDragging = true;
        // Store initial position for potential undo
        dragStartPosition = { ...treat.position };
        lastDragHit = null;

        // Change cursor to grabbing
        renderer.domElement.style.cursor = 'grabbing';

        console.log('Started dragging treat:', selectedPlacedTreatId);
      }

      /**
       * Update treat position during drag (Requirements 3.3, 3.4)
       * @param {number} clientX - Mouse X position
       * @param {number} clientY - Mouse Y position
       */
      function updateDrag(clientX, clientY) {
        if (!isDragging || !selectedPlacedTreatId || !treatManager || !raycastSystem) return;

        const hit = raycastSystem.raycastFromEvent(clientX, clientY, renderer.domElement);

        if (hit) {
          // Update treat position in real-time (Requirement 3.4)
          treatManager.updateTreatPosition(selectedPlacedTreatId, hit);
          lastDragHit = hit;

          // Update surface ring to show new position
          updateSurfaceRing(hit);
        }
      }

      /**
       * End drag and commit position (Requirement 3.5)
       */
      function endDrag() {
        if (!isDragging) return;

        isDragging = false;

        // Hide surface ring
        hideSurfaceRing();

        // Restore cursor
        if (selectedPlacedTreatId) {
          renderer.domElement.style.cursor = 'pointer';
        } else {
          renderer.domElement.style.cursor = 'default';
        }

        console.log(
          'Ended dragging treat:',
          selectedPlacedTreatId,
          'at position:',
          lastDragHit?.position
        );

        // Clear drag state
        dragStartPosition = null;
        lastDragHit = null;
      }

      /**
       * Cancel drag and restore original position
       */
      function cancelDrag() {
        if (!isDragging || !selectedPlacedTreatId || !dragStartPosition) return;

        // Restore original position
        const mesh = treatManager.getMesh(selectedPlacedTreatId);
        if (mesh) {
          mesh.position.set(dragStartPosition.x, dragStartPosition.y, dragStartPosition.z);
          const treat = treatManager.getTreat(selectedPlacedTreatId);
          if (treat) {
            treat.position = { ...dragStartPosition };
          }
        }

        endDrag();
        console.log('Cancelled drag, restored position');
      }

      // ============================================
      // Mouse Event Handlers for Drag-to-Reposition
      // ============================================

      // Mousedown to start drag on selected treat (Requirement 3.3)
      renderer.domElement.addEventListener('mousedown', (e) => {
        if (isMobile) return;
        if (!modeManager.isEditMode()) return;
        if (isInPlacementMode) return;
        if (isLocked) return;

        // Check if we clicked on the currently selected treat
        if (selectedPlacedTreatId) {
          const clickedTreatId = raycastTreats(e.clientX, e.clientY);
          if (clickedTreatId === selectedPlacedTreatId) {
            // Start drag on the selected treat
            startDrag(e.clientX, e.clientY);
            e.preventDefault();
          }
        }
      });

      // Mouseup to end drag (Requirement 3.5)
      document.addEventListener('mouseup', (e) => {
        if (isDragging) {
          endDrag();
        }
      });

      // Update ghost preview position on mouse move (Requirements 1.1, 1.2)
      // Also handles hover highlighting in edit mode (Requirement 6.3)
      // Also handles drag-to-reposition (Requirements 3.3, 3.4)
      renderer.domElement.addEventListener('mousemove', (e) => {
        // Handle drag-to-reposition (Requirements 3.3, 3.4)
        if (isDragging) {
          updateDrag(e.clientX, e.clientY);
          return; // Don't process other mousemove logic while dragging
        }

        // Handle hover highlighting in edit mode when not in placement mode (Requirement 6.3)
        if (modeManager.isEditMode() && !isInPlacementMode && selectionManager && !isLocked) {
          const hoveredTreatId = raycastTreats(e.clientX, e.clientY);
          selectionManager.setHovered(hoveredTreatId);

          // Change cursor to pointer when hovering over a treat
          // Show grab cursor when hovering over selected treat
          if (hoveredTreatId === selectedPlacedTreatId && selectedPlacedTreatId) {
            renderer.domElement.style.cursor = 'grab';
          } else {
            renderer.domElement.style.cursor = hoveredTreatId ? 'pointer' : 'default';
          }
        }

        // Handle ghost preview positioning during placement mode
        if (!isInPlacementMode || !ghostPreview || !raycastSystem || isLocked) return;

        const hit = raycastSystem.raycastFromEvent(e.clientX, e.clientY, renderer.domElement);

        if (hit) {
          // Valid surface hit - show ghost at position (Requirement 1.2)
          const offset = treatManager ? treatManager.getOffset() : { x: 0, y: 0, z: 0 };
          ghostPreview.setPosition(hit, offset);
          ghostPreview.setValid(true);
          ghostPreview.show();
          updateSurfaceRing(hit);
          lastValidHit = hit;
        } else {
          // No valid surface - show invalid state (Requirement 1.3)
          ghostPreview.setValid(false);
          hideSurfaceRing();
          lastValidHit = null;
        }
      });

      // Touch move for mobile ghost preview
      renderer.domElement.addEventListener(
        'touchmove',
        (e) => {
          if (!isInPlacementMode || !ghostPreview || !raycastSystem) return;
          if (e.touches.length !== 1) return; // Only single touch for positioning

          const touch = e.touches[0];
          const hit = raycastSystem.raycastFromEvent(
            touch.clientX,
            touch.clientY,
            renderer.domElement
          );

          if (hit) {
            const offset = treatManager ? treatManager.getOffset() : { x: 0, y: 0, z: 0 };
            ghostPreview.setPosition(hit, offset);
            ghostPreview.setValid(true);
            ghostPreview.show();
            updateSurfaceRing(hit);
            lastValidHit = hit;
          } else {
            ghostPreview.setValid(false);
            hideSurfaceRing();
            lastValidHit = null;
          }
        },
        { passive: true }
      );

      // Escape key to cancel placement mode (Requirement 2.4) and deselect treats (Requirement 3.6)
      document.addEventListener('keydown', (e) => {
        if (e.code === 'Escape') {
          if (isInPlacementMode) {
            // Cancel placement mode
            exitPlacementMode();
            if (treatManager) treatManager.clearSelection();
            // Clear preset selections
            document
              .querySelectorAll('.preset-btn')
              .forEach((btn) => btn.classList.remove('selected'));
            showStatus('Placement cancelled', 'ready');
            setTimeout(hideStatus, 1500);
          } else if (selectedPlacedTreatId) {
            // Deselect the currently selected treat (Requirement 3.6)
            deselectPlacedTreat();
            showStatus('Treat deselected', 'ready');
            setTimeout(hideStatus, 1500);
          }
        }
      });

      // Desktop pointer lock for mouse look (only in explore mode)
      renderer.domElement.addEventListener('click', (e) => {
        if (isMobile) return;

        if (modeManager.isEditMode()) {
          // First, check if we clicked on a placed treat
          const clickedTreatId = raycastTreats(e.clientX, e.clientY);
          if (clickedTreatId) {
            treatManager.onTreatClick(clickedTreatId);
            return;
          }

          // Clicked elsewhere - deselect any selected treat (Requirement 3.6)
          if (selectedPlacedTreatId && !isInPlacementMode) {
            deselectPlacedTreat();
            // Don't return - continue to check for other actions
          }

          // If a treat is selected and we're in placement mode, confirm placement
          // (Requirements 2.1, 2.2)
          if (!raycastSystem || !treatManager) return; // Not loaded yet
          if (treatManager.hasSelection() && isInPlacementMode && ghostPreview) {
            // Check if ghost preview is in a valid state
            if (!ghostPreview.isValidState() || !ghostPreview.isVisible()) {
              console.log('Cannot place - ghost preview is not in valid state');
              showMissIndicator();
              window.dispatchEvent(new CustomEvent('raycast-miss'));
              return;
            }

            // Get the transform from ghost preview (Requirement 2.1)
            const ghostTransform = ghostPreview.getTransform();
            if (ghostTransform) {
              console.log('Placing treat at ghost position:', ghostTransform.position);
              // Place at ghost position with full opacity (Requirement 2.2)
              const placedTreat = treatManager.placeTreatAtTransform(ghostTransform);
              if (placedTreat) {
                showHitMarker({ position: ghostTransform.position });
                window.dispatchEvent(new CustomEvent('treat-placed', { detail: placedTreat }));

                // Exit placement mode and select the newly placed treat for adjustment (Requirement 2.3)
                exitPlacementMode();
                treatManager.clearSelection();
                // Clear preset selections in UI
                document
                  .querySelectorAll('.preset-btn')
                  .forEach((btn) => btn.classList.remove('selected'));
                // Select the newly placed treat for adjustment
                selectPlacedTreatForAdjustment(placedTreat.id);
                showStatus('‚úì Treat placed! Selected for adjustment.', 'ready');
                setTimeout(hideStatus, 2000);
              }
            } else {
              console.log('No ghost transform available');
              showMissIndicator();
              window.dispatchEvent(new CustomEvent('raycast-miss'));
            }
          } else if (treatManager.hasSelection() && !isInPlacementMode) {
            // Selection exists but not in placement mode - enter placement mode
            enterPlacementMode();
            showStatus('Move cursor to preview placement position', 'ready');
          } else if (!selectedPlacedTreatId) {
            // No treat selected and no placed treat selected, just show hit marker for feedback
            const hit = raycastSystem.raycastFromEvent(e.clientX, e.clientY, renderer.domElement);
            if (hit) {
              showHitMarker(hit);
              showStatus('Select a treat first!', 'error');
              setTimeout(hideStatus, 2000);
            }
          }
          return;
        }

        // In explore mode, check for treat clicks first
        const clickedTreatId = raycastTreats(e.clientX, e.clientY);
        if (clickedTreatId && treatManager) {
          treatManager.onTreatClick(clickedTreatId);
          return;
        }

        // Otherwise, request pointer lock for mouse look
        renderer.domElement.requestPointerLock();
      });

      document.addEventListener('pointerlockchange', () => {
        isLocked = document.pointerLockElement === renderer.domElement;
      });

      document.addEventListener('mousemove', (e) => {
        if (!isLocked) return;
        euler.setFromQuaternion(camera.quaternion);
        euler.y -= e.movementX * CONFIG.lookSensitivity;
        euler.x -= e.movementY * CONFIG.lookSensitivity;
        euler.x = Math.max(-CONFIG.maxPitch, Math.min(CONFIG.maxPitch, euler.x));
        camera.quaternion.setFromEuler(euler);
        // Update admin tracking
        if (isAdminMode) {
          pitch = euler.x;
          yaw = euler.y;
        }
      });

      // Helper to find touch by identifier
      function findTouchById(touches, id) {
        for (const touch of touches) {
          if (touch.identifier === id) return touch;
        }
        return null;
      }

      // Mobile joystick
      let joystickTouchId = null;
      const joystickCenter = { x: 60, y: 60 }; // center of 120px zone

      joystickZone.addEventListener(
        'touchstart',
        (e) => {
          e.preventDefault();
          const touch = e.changedTouches[0];
          joystickTouchId = touch.identifier;
          updateJoystick(touch);
        },
        { passive: false }
      );

      joystickZone.addEventListener(
        'touchmove',
        (e) => {
          e.preventDefault();
          const touch = findTouchById(e.changedTouches, joystickTouchId);
          if (touch) updateJoystick(touch);
        },
        { passive: false }
      );

      joystickZone.addEventListener('touchend', (e) => {
        if (findTouchById(e.changedTouches, joystickTouchId)) {
          joystickTouchId = null;
          joystickInput.x = 0;
          joystickInput.y = 0;
          joystickStick.style.transform = 'translate(-50%, -50%)';
        }
      });

      function updateJoystick(touch) {
        const rect = joystickZone.getBoundingClientRect();
        let dx = touch.clientX - rect.left - joystickCenter.x;
        let dy = touch.clientY - rect.top - joystickCenter.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist > CONFIG.joystickMaxDist) {
          dx = (dx / dist) * CONFIG.joystickMaxDist;
          dy = (dy / dist) * CONFIG.joystickMaxDist;
        }

        joystickInput.x = dx / CONFIG.joystickMaxDist;
        joystickInput.y = -dy / CONFIG.joystickMaxDist; // invert Y

        joystickStick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
      }

      // Mobile touch look (right side of screen)
      let lookTouchId = null;
      let lastLookX = 0,
        lastLookY = 0;
      let touchStartTime = 0;
      let touchStartPos = { x: 0, y: 0 };
      const TAP_THRESHOLD_MS = 200;
      const TAP_MOVE_THRESHOLD = 10;

      renderer.domElement.addEventListener('touchstart', (e) => {
        for (const touch of e.changedTouches) {
          // Only use touches on right 70% of screen for look
          if (touch.clientX > window.innerWidth * 0.3 && lookTouchId === null) {
            lookTouchId = touch.identifier;
            lastLookX = touch.clientX;
            lastLookY = touch.clientY;
            touchStartTime = Date.now();
            touchStartPos = { x: touch.clientX, y: touch.clientY };
            break;
          }
        }
      });

      renderer.domElement.addEventListener('touchmove', (e) => {
        const touch = findTouchById(e.changedTouches, lookTouchId);
        if (!touch) return;

        const dx = touch.clientX - lastLookX;
        const dy = touch.clientY - lastLookY;
        lastLookX = touch.clientX;
        lastLookY = touch.clientY;

        euler.setFromQuaternion(camera.quaternion);
        euler.y -= dx * CONFIG.mobileLookSensitivity;
        euler.x -= dy * CONFIG.mobileLookSensitivity;
        euler.x = Math.max(-CONFIG.maxPitch, Math.min(CONFIG.maxPitch, euler.x));
        camera.quaternion.setFromEuler(euler);
        // Update admin tracking
        if (isAdminMode) {
          pitch = euler.x;
          yaw = euler.y;
        }
      });

      renderer.domElement.addEventListener('touchend', (e) => {
        const touch = findTouchById(e.changedTouches, lookTouchId);
        if (touch) {
          // Check if this was a tap (short duration, minimal movement)
          const duration = Date.now() - touchStartTime;
          const dx = touch.clientX - touchStartPos.x;
          const dy = touch.clientY - touchStartPos.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (duration < TAP_THRESHOLD_MS && distance < TAP_MOVE_THRESHOLD) {
            // This was a tap - check for treat clicks first
            if (!raycastSystem || !treatManager) return; // Not loaded yet
            const clickedTreatId = raycastTreats(touch.clientX, touch.clientY);
            if (clickedTreatId) {
              treatManager.onTreatClick(clickedTreatId);
            } else if (modeManager.isEditMode()) {
              // In edit mode, try to place a treat using ghost preview position
              // (Requirements 2.1, 2.2)
              if (treatManager.hasSelection() && isInPlacementMode && ghostPreview) {
                // Check if ghost preview is in a valid state
                if (!ghostPreview.isValidState() || !ghostPreview.isVisible()) {
                  console.log('Mobile: Cannot place - ghost preview is not in valid state');
                  showMissIndicator();
                  window.dispatchEvent(new CustomEvent('raycast-miss'));
                  return;
                }

                // Get the transform from ghost preview (Requirement 2.1)
                const ghostTransform = ghostPreview.getTransform();
                if (ghostTransform) {
                  console.log('Mobile: Placing treat at ghost position:', ghostTransform.position);
                  // Place at ghost position with full opacity (Requirement 2.2)
                  const placedTreat = treatManager.placeTreatAtTransform(ghostTransform);
                  if (placedTreat) {
                    showHitMarker({ position: ghostTransform.position });
                    window.dispatchEvent(new CustomEvent('treat-placed', { detail: placedTreat }));

                    // Exit placement mode and select the newly placed treat for adjustment (Requirement 2.3)
                    exitPlacementMode();
                    treatManager.clearSelection();
                    // Clear preset selections in UI
                    document
                      .querySelectorAll('.preset-btn')
                      .forEach((btn) => btn.classList.remove('selected'));
                    // Select the newly placed treat for adjustment
                    selectPlacedTreatForAdjustment(placedTreat.id);
                    showStatus('‚úì Treat placed! Selected for adjustment.', 'ready');
                    setTimeout(hideStatus, 2000);
                  }
                } else {
                  console.log('Mobile: No ghost transform available');
                  showMissIndicator();
                  window.dispatchEvent(new CustomEvent('raycast-miss'));
                }
              } else if (treatManager.hasSelection() && !isInPlacementMode) {
                // Selection exists but not in placement mode - enter placement mode
                enterPlacementMode();
                showStatus('Move finger to preview placement position', 'ready');
              } else {
                // No treat selected
                const hit = raycastSystem.raycastFromEvent(
                  touch.clientX,
                  touch.clientY,
                  renderer.domElement
                );
                if (hit) {
                  showHitMarker(hit);
                  showStatus('Select a treat first!', 'error');
                  setTimeout(hideStatus, 2000);
                }
              }
            }
          }

          lookTouchId = null;
        }
      });

      // ============================================
      // Proximity Message Detection (Explore Mode)
      // With center-screen highlighting for disambiguation
      // ============================================
      const PROXIMITY_DISTANCE = 3.0; // Distance in world units to detect messages
      const proximityIndicator = document.getElementById('proximity-indicator');
      const reticleEl = document.getElementById('reticle');
      let nearbyMessageTreat = null; // Track the treat to interact with
      let centeredTreatId = null; // Track the treat user is looking at (center screen)
      let lastCenteredTreatId = null; // For detecting changes

      // Reusable objects for center-screen raycast
      const centerRaycaster = new THREE.Raycaster();
      const centerScreenCoords = new THREE.Vector2(0, 0); // Always center

      // Store original emissive values for centered treat highlight
      const centeredTreatOriginalEmissive = new Map();
      const CENTERED_HIGHLIGHT_COLOR = new THREE.Color(0x00ffaa); // Cyan-green glow
      const CENTERED_HIGHLIGHT_INTENSITY = 0.4;

      /**
       * Apply highlight glow to the treat the user is looking at
       * @param {string} treatId - ID of the treat to highlight
       */
      function applyCenteredHighlight(treatId) {
        if (!treatManager) return;
        const mesh = treatManager.getMesh(treatId);
        if (!mesh) return;

        // Store original emissive values
        centeredTreatOriginalEmissive.clear();
        mesh.traverse((child) => {
          if (child.isMesh && child.material) {
            const materials = Array.isArray(child.material) ? child.material : [child.material];
            materials.forEach((mat, index) => {
              if (mat.emissive) {
                const key = `${child.uuid}-${index}`;
                centeredTreatOriginalEmissive.set(key, {
                  emissive: mat.emissive.clone(),
                  emissiveIntensity: mat.emissiveIntensity || 0,
                });
                // Apply highlight
                mat.emissive.copy(CENTERED_HIGHLIGHT_COLOR);
                mat.emissiveIntensity = CENTERED_HIGHLIGHT_INTENSITY;
              }
            });
          }
        });
      }

      /**
       * Remove highlight glow from the previously centered treat
       * @param {string} treatId - ID of the treat to unhighlight
       */
      function removeCenteredHighlight(treatId) {
        if (!treatManager) return;
        const mesh = treatManager.getMesh(treatId);
        if (!mesh) return;

        mesh.traverse((child) => {
          if (child.isMesh && child.material) {
            const materials = Array.isArray(child.material) ? child.material : [child.material];
            materials.forEach((mat, index) => {
              if (mat.emissive) {
                const key = `${child.uuid}-${index}`;
                const original = centeredTreatOriginalEmissive.get(key);
                if (original) {
                  mat.emissive.copy(original.emissive);
                  mat.emissiveIntensity = original.emissiveIntensity;
                } else {
                  // Fallback to black emissive
                  mat.emissive.setHex(0x000000);
                  mat.emissiveIntensity = 0;
                }
              }
            });
          }
        });
        centeredTreatOriginalEmissive.clear();
      }

      /**
       * Raycast from center of screen to find treat user is looking at
       * @returns {string|null} Treat ID or null
       */
      function raycastCenterScreen() {
        if (!treatManager) return null;

        centerRaycaster.setFromCamera(centerScreenCoords, camera);

        const meshes = treatManager.getAllMeshes();
        if (meshes.length === 0) return null;

        const intersections = centerRaycaster.intersectObjects(meshes, true);

        if (intersections.length > 0) {
          // Find the treat ID from the intersected object or its parents
          let obj = intersections[0].object;
          while (obj) {
            if (obj.userData && obj.userData.treatId) {
              return obj.userData.treatId;
            }
            obj = obj.parent;
          }
        }
        return null;
      }

      /**
       * Check for nearby message bottles and show indicator
       * Prioritizes the treat user is looking at (center screen)
       * Called in render loop when in explore mode
       */
      function checkProximityMessages() {
        if (!treatManager || modeManager.isEditMode()) {
          proximityIndicator.classList.remove('visible');
          reticleEl.classList.add('hidden');
          nearbyMessageTreat = null;
          // Remove any existing highlight
          if (lastCenteredTreatId) {
            removeCenteredHighlight(lastCenteredTreatId);
            lastCenteredTreatId = null;
          }
          centeredTreatId = null;
          return;
        }

        // Show reticle in explore mode
        reticleEl.classList.remove('hidden');

        const treats = treatManager.getAllTreats();
        const cameraPos = camera.position;

        // First, check what treat user is looking at (center screen raycast)
        const lookingAtTreatId = raycastCenterScreen();

        // Update centered highlight and reticle state
        if (lookingAtTreatId !== lastCenteredTreatId) {
          // Remove old highlight
          if (lastCenteredTreatId) {
            removeCenteredHighlight(lastCenteredTreatId);
          }
          // Apply new highlight
          if (lookingAtTreatId) {
            applyCenteredHighlight(lookingAtTreatId);
            reticleEl.classList.add('active');
          } else {
            reticleEl.classList.remove('active');
          }
          lastCenteredTreatId = lookingAtTreatId;
        }
        centeredTreatId = lookingAtTreatId;

        // If looking at a treat with a message, prioritize it
        if (lookingAtTreatId) {
          const lookingAtTreat = treatManager.getTreat(lookingAtTreatId);
          if (lookingAtTreat && lookingAtTreat.metadata && lookingAtTreat.metadata.text) {
            nearbyMessageTreat = lookingAtTreat;
            proximityIndicator.classList.add('visible');
            return;
          }
        }

        // Fallback: find closest treat with message within proximity
        let closestTreat = null;
        let closestDistance = PROXIMITY_DISTANCE;

        for (const treat of treats) {
          // Only check treats with messages
          if (!treat.metadata || !treat.metadata.text) continue;

          // Calculate distance to treat
          const dx = treat.position.x - cameraPos.x;
          const dy = treat.position.y - cameraPos.y;
          const dz = treat.position.z - cameraPos.z;
          const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);

          if (distance < closestDistance) {
            closestDistance = distance;
            closestTreat = treat;
          }
        }

        nearbyMessageTreat = closestTreat;

        if (closestTreat) {
          proximityIndicator.classList.add('visible');
        } else {
          proximityIndicator.classList.remove('visible');
        }
      }

      // Click on proximity indicator to read message
      proximityIndicator.addEventListener('click', () => {
        if (nearbyMessageTreat && nearbyMessageTreat.metadata && nearbyMessageTreat.metadata.text) {
          showMessageModal(nearbyMessageTreat.metadata.text);
        }
      });

      // Press E to read nearby message
      document.addEventListener('keydown', (e) => {
        if (e.code === 'KeyE' && nearbyMessageTreat && modeManager.isExploreMode()) {
          if (nearbyMessageTreat.metadata && nearbyMessageTreat.metadata.text) {
            showMessageModal(nearbyMessageTreat.metadata.text);
          }
        }
      });

      // ============================================
      // Treat Editor Panel - Contextual editing UI
      // ============================================
      const treatEditorEl = document.getElementById('treat-editor');
      const editorMessageInput = document.getElementById('editor-message');
      const editorCharCount = document.getElementById('editor-char-count');
      const editorToast = document.getElementById('editor-toast');
      let currentEditingTreatId = null;
      let editorOriginalMessage = ''; // Track original for dirty state

      /**
       * Show the treat editor panel for a specific treat
       * @param {string} treatId - ID of the treat to edit
       */
      function showTreatEditor(treatId) {
        if (!treatManager) return;
        const treat = treatManager.getTreat(treatId);
        if (!treat) return;

        currentEditingTreatId = treatId;

        // Populate message field
        const message = treat.metadata?.text || '';
        editorMessageInput.value = message;
        editorOriginalMessage = message;
        updateEditorCharCount();

        // Reset to message tab
        document.querySelectorAll('.treat-editor-tab').forEach((t) => t.classList.remove('active'));
        document
          .querySelectorAll('.treat-editor-section')
          .forEach((s) => s.classList.remove('active'));
        document.querySelector('.treat-editor-tab[data-tab="message"]').classList.add('active');
        document
          .querySelector('.treat-editor-section[data-section="message"]')
          .classList.add('active');

        // Show editor
        treatEditorEl.classList.add('visible');

        // Focus message input after a brief delay
        setTimeout(() => editorMessageInput.focus(), 100);
      }

      /**
       * Hide the treat editor panel
       */
      function hideTreatEditor() {
        treatEditorEl.classList.remove('visible');
        currentEditingTreatId = null;
        editorOriginalMessage = '';
      }

      /**
       * Update character count display
       */
      function updateEditorCharCount() {
        const len = editorMessageInput.value.length;
        editorCharCount.textContent = `${len} / 280`;
        editorCharCount.classList.remove('warning', 'error');
        if (len > 250) editorCharCount.classList.add('warning');
        if (len >= 280) editorCharCount.classList.add('error');
      }

      /**
       * Show toast notification
       * @param {string} message - Message to show
       * @param {boolean} isError - Whether this is an error
       */
      function showEditorToast(message, isError = false) {
        editorToast.textContent = message;
        editorToast.classList.toggle('error', isError);
        editorToast.classList.add('visible');
        setTimeout(() => editorToast.classList.remove('visible'), 2000);
      }

      /**
       * Save changes to the current treat
       */
      function saveCurrentTreat() {
        if (!currentEditingTreatId || !treatManager) return;

        const treat = treatManager.getTreat(currentEditingTreatId);
        if (!treat) return;

        // Update message
        const newMessage = editorMessageInput.value.trim();
        if (!treat.metadata) treat.metadata = {};
        treat.metadata.text = newMessage || undefined;

        editorOriginalMessage = newMessage;
        showEditorToast('‚úì Changes saved!');

        // Update placed treats list
        updatePlacedTreatsList();
      }

      /**
       * Delete the current treat
       */
      function deleteCurrentTreat() {
        if (!currentEditingTreatId || !treatManager) return;

        treatManager.removeTreat(currentEditingTreatId);
        hideTreatEditor();
        deselectPlacedTreat();
        showEditorToast('Treat deleted');
        updatePlacedTreatsList();
      }

      /**
       * Duplicate the current treat
       */
      async function duplicateCurrentTreat() {
        if (!currentEditingTreatId || !treatManager) return;

        const treat = treatManager.getTreat(currentEditingTreatId);
        if (!treat) return;

        try {
          // Select the same treat type for placement
          await treatManager.selectTreat(treat.glbUrl, treat.type);

          // Copy the message
          if (treat.metadata?.text) {
            treatManager.setMetadata({ text: treat.metadata.text });
          }

          // Load ghost preview
          if (ghostPreview) {
            await ghostPreview.load(treat.glbUrl);
          }

          // Enter placement mode
          hideTreatEditor();
          deselectPlacedTreat();
          enterPlacementMode();

          showStatus('Move to place duplicate', 'ready');
        } catch (error) {
          showEditorToast('Failed to duplicate', true);
        }
      }

      // Tab switching
      document.querySelectorAll('.treat-editor-tab').forEach((tab) => {
        tab.addEventListener('click', () => {
          const tabName = tab.dataset.tab;

          // Update tab active state
          document
            .querySelectorAll('.treat-editor-tab')
            .forEach((t) => t.classList.remove('active'));
          tab.classList.add('active');

          // Update section visibility
          document
            .querySelectorAll('.treat-editor-section')
            .forEach((s) => s.classList.remove('active'));
          document
            .querySelector(`.treat-editor-section[data-section="${tabName}"]`)
            .classList.add('active');
        });
      });

      // Character count update
      editorMessageInput.addEventListener('input', updateEditorCharCount);

      // Close button
      document.getElementById('close-editor-btn').addEventListener('click', () => {
        hideTreatEditor();
        deselectPlacedTreat();
      });

      // Save button
      document.getElementById('editor-save-btn').addEventListener('click', saveCurrentTreat);

      // Delete button
      document.getElementById('editor-delete-btn').addEventListener('click', deleteCurrentTreat);

      // Duplicate button
      document
        .getElementById('editor-duplicate-btn')
        .addEventListener('click', duplicateCurrentTreat);

      // Reposition button - enters drag mode
      document.getElementById('editor-reposition-btn').addEventListener('click', () => {
        if (!currentEditingTreatId) return;

        // The treat is already selected, just inform user to drag
        showEditorToast('Click and drag the treat to move it');

        // Highlight the reposition button as active
        const btn = document.getElementById('editor-reposition-btn');
        btn.classList.add('active');
        setTimeout(() => btn.classList.remove('active'), 2000);
      });

      // Reset position button (placeholder - would need original position tracking)
      document.getElementById('editor-reset-btn').addEventListener('click', () => {
        showEditorToast('Position reset not available', true);
      });

      // Listen for treat selection to show editor
      window.addEventListener('treat-selected-for-adjustment', (e) => {
        const { treatId } = e.detail;
        if (treatId && modeManager.isEditMode()) {
          showTreatEditor(treatId);
          updatePlacedTreatsList(); // Update list to show selection
        }
      });

      // Listen for treat deselection to hide editor
      window.addEventListener('treat-deselected', () => {
        hideTreatEditor();
        updatePlacedTreatsList(); // Update list to clear selection
      });

      // Hide editor when switching to explore mode
      modeManager.onModeChange((mode) => {
        if (mode === 'explore') {
          hideTreatEditor();
        }
      });

      // ============================================
      // Share Functionality
      // ============================================

      // AWS Configuration (from environment or defaults)
      const AWS_CONFIG = {
        region: 'us-east-1',
        identityPoolId: 'us-east-1:8988c26a-2063-4e34-9ef3-c65c9aa7103f',
        bucketName: 'splatntreat',
        appUrl: window.location.origin,
      };

      // Share modal elements
      const shareBtn = document.getElementById('share-btn');
      const shareModal = document.getElementById('share-modal');
      const shareStatus = document.getElementById('share-status');
      const shareUrlContainer = document.getElementById('share-url-container');
      const shareUrlInput = document.getElementById('share-url-input');
      const copyUrlBtn = document.getElementById('copy-url-btn');
      const closeShareModalBtn = document.getElementById('close-share-modal-btn');
      const shareTreatCount = document.getElementById('share-treat-count');

      // Current scene ID (set after first save)
      let currentSceneId = null;

      /**
       * Generate a UUID v4
       */
      function generateUUID() {
        if (typeof crypto !== 'undefined' && crypto.randomUUID) {
          return crypto.randomUUID();
        }
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
          const r = (Math.random() * 16) | 0;
          const v = c === 'x' ? r : (r & 0x3) | 0x8;
          return v.toString(16);
        });
      }

      /**
       * Build scene state from current treats
       */
      function buildSceneState() {
        const treats = treatManager ? treatManager.getAllTreats() : [];
        return {
          version: 1,
          worldUrl: worldUrl || '',
          treats: treats.map((t) => ({
            id: t.id,
            type: t.type,
            glbUrl: t.glbUrl,
            position: { x: t.position.x, y: t.position.y, z: t.position.z },
            rotation: {
              x: t.rotation.x,
              y: t.rotation.y,
              z: t.rotation.z,
              order: t.rotation.order || 'XYZ',
            },
            scale: { x: t.scale.x, y: t.scale.y, z: t.scale.z },
            metadata: { ...t.metadata },
          })),
          waypoints: [],
          paths: [],
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
        };
      }

      /**
       * Save scene to S3 using AWS SDK
       */
      async function saveSceneToS3(sceneState) {
        // Dynamically import AWS SDK from esm.sh (better ESM compatibility than jsdelivr)
        const { S3Client, PutObjectCommand } = await import(
          'https://esm.sh/@aws-sdk/client-s3@3.600.0'
        );
        const { fromCognitoIdentityPool } = await import(
          'https://esm.sh/@aws-sdk/credential-providers@3.600.0'
        );

        const s3Client = new S3Client({
          region: AWS_CONFIG.region,
          credentials: fromCognitoIdentityPool({
            identityPoolId: AWS_CONFIG.identityPoolId,
            clientConfig: { region: AWS_CONFIG.region },
          }),
        });

        const sceneId = currentSceneId || generateUUID();
        const s3Key = `scenes/${sceneId}.json`;

        // Update timestamps
        sceneState.updatedAt = new Date().toISOString();
        if (!currentSceneId) {
          sceneState.createdAt = sceneState.updatedAt;
        }

        await s3Client.send(
          new PutObjectCommand({
            Bucket: AWS_CONFIG.bucketName,
            Key: s3Key,
            Body: JSON.stringify(sceneState),
            ContentType: 'application/json',
          })
        );

        currentSceneId = sceneId;
        return {
          sceneId,
          shareUrl: `${AWS_CONFIG.appUrl}?scene=${encodeURIComponent(sceneId)}`,
          s3Key,
        };
      }

      /**
       * Show share modal and save scene
       */
      async function showShareModal() {
        const treats = treatManager ? treatManager.getAllTreats() : [];
        shareTreatCount.textContent = `${treats.length} treat${treats.length !== 1 ? 's' : ''} placed`;

        // Show modal
        shareModal.classList.add('visible');

        // Reset state
        shareStatus.style.display = 'flex';
        shareStatus.className = 'share-status saving';
        shareStatus.innerHTML = '<div class="spinner-small"></div><span>Saving scene...</span>';
        shareUrlContainer.style.display = 'none';

        try {
          const sceneState = buildSceneState();
          const result = await saveSceneToS3(sceneState);

          // Show success
          shareStatus.className = 'share-status success';
          shareStatus.innerHTML = '‚úì Scene saved successfully!';

          // Show URL
          shareUrlInput.value = result.shareUrl;
          shareUrlContainer.style.display = 'flex';
        } catch (error) {
          console.error('Failed to save scene:', error);
          shareStatus.className = 'share-status error';
          shareStatus.innerHTML = `‚úï Failed to save: ${error.message}`;
        }
      }

      /**
       * Copy share URL to clipboard
       */
      async function copyShareUrl() {
        try {
          await navigator.clipboard.writeText(shareUrlInput.value);
          copyUrlBtn.textContent = '‚úì Copied!';
          copyUrlBtn.classList.add('copied');
          setTimeout(() => {
            copyUrlBtn.textContent = 'üìã Copy';
            copyUrlBtn.classList.remove('copied');
          }, 2000);
        } catch (error) {
          // Fallback for older browsers
          shareUrlInput.select();
          document.execCommand('copy');
          copyUrlBtn.textContent = '‚úì Copied!';
          copyUrlBtn.classList.add('copied');
          setTimeout(() => {
            copyUrlBtn.textContent = 'üìã Copy';
            copyUrlBtn.classList.remove('copied');
          }, 2000);
        }
      }

      // Share button click
      shareBtn.addEventListener('click', showShareModal);

      // Copy URL button click
      copyUrlBtn.addEventListener('click', copyShareUrl);

      // Close share modal
      closeShareModalBtn.addEventListener('click', () => {
        shareModal.classList.remove('visible');
      });

      // Close modal on backdrop click
      shareModal.addEventListener('click', (e) => {
        if (e.target === shareModal) {
          shareModal.classList.remove('visible');
        }
      });

      // Close modal on Escape key
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && shareModal.classList.contains('visible')) {
          shareModal.classList.remove('visible');
        }
      });

      /**
       * Load scene from S3 by scene ID
       * @param {string} sceneId - The scene ID to load
       * @returns {Promise<Object|null>} The scene state or null if not found
       */
      async function loadSceneFromS3(sceneId) {
        try {
          const { S3Client, GetObjectCommand } = await import(
            'https://esm.sh/@aws-sdk/client-s3@3.600.0'
          );
          const { fromCognitoIdentityPool } = await import(
            'https://esm.sh/@aws-sdk/credential-providers@3.600.0'
          );

          const s3Client = new S3Client({
            region: AWS_CONFIG.region,
            credentials: fromCognitoIdentityPool({
              identityPoolId: AWS_CONFIG.identityPoolId,
              clientConfig: { region: AWS_CONFIG.region },
            }),
          });

          const s3Key = `scenes/${sceneId}.json`;

          const response = await s3Client.send(
            new GetObjectCommand({
              Bucket: AWS_CONFIG.bucketName,
              Key: s3Key,
            })
          );

          if (!response.Body) {
            return null;
          }

          // Convert stream to string
          const bodyString = await response.Body.transformToString();
          return JSON.parse(bodyString);
        } catch (error) {
          if (error.name === 'NoSuchKey') {
            console.warn('Scene not found:', sceneId);
            return null;
          }
          throw error;
        }
      }

      /**
       * Restore treats from a loaded scene state
       * @param {Object} sceneState - The scene state to restore
       */
      async function restoreSceneState(sceneState) {
        if (!sceneState || !sceneState.treats || !treatManager) {
          console.warn('Cannot restore scene: invalid state or treatManager not ready');
          return;
        }

        console.log(`üîÑ Restoring ${sceneState.treats.length} treats from shared scene`);

        for (const treat of sceneState.treats) {
          try {
            // Load the GLB model
            await treatManager.selectTreat(treat.glbUrl, treat.type);

            // Set metadata
            if (treat.metadata) {
              treatManager.setMetadata(treat.metadata);
            }

            // Place at the saved transform
            const placedTreat = treatManager.placeTreatAtTransform({
              position: treat.position,
              rotation: treat.rotation,
              scale: treat.scale,
            }, treat.metadata);

            if (placedTreat) {
              console.log(`‚úì Restored treat: ${treat.id}`);
            }
          } catch (error) {
            console.error(`Failed to restore treat ${treat.id}:`, error);
          }
        }

        // Clear selection after restoring
        treatManager.clearSelection();

        // Update the placed treats list
        updatePlacedTreatsList();

        console.log('‚úÖ Scene restoration complete');
      }

      /**
       * Check for scene parameter and load shared scene
       */
      async function checkAndLoadSharedScene() {
        if (!sceneIdParam) return;

        console.log('üîó Loading shared scene:', sceneIdParam);
        currentSceneId = sceneIdParam;

        try {
          const sceneState = await loadSceneFromS3(sceneIdParam);

          if (sceneState) {
            // Update world URL from scene state if different
            if (sceneState.worldUrl && sceneState.worldUrl !== worldUrl) {
              console.log('‚ö†Ô∏è Scene was created in a different world:', sceneState.worldUrl);
              // For now, we'll still restore treats in the current world
            }

            await restoreSceneState(sceneState);
            showEditorToast(`Loaded shared scene with ${sceneState.treats.length} treats`);
          } else {
            console.warn('Shared scene not found');
            showEditorToast('Shared scene not found', true);
          }
        } catch (error) {
          console.error('Failed to load shared scene:', error);
          showEditorToast('Failed to load shared scene', true);
        }
      }

      // Animation loop - reuse direction vector to reduce GC pressure
      const clock = new THREE.Clock();
      const direction = new THREE.Vector3();

      // Track load-in effect animation
      let loadInStartTime = null;
      const LOAD_IN_DURATION = 3.0; // seconds for effect to fade out

      renderer.setAnimationLoop((time) => {
        const delta = clock.getDelta();
        const timeSeconds = time / 1000;

        // Update shader animation time
        animateT.value = timeSeconds;

        // Update load-in effect progress (fade from effect to normal)
        if (splatMesh) {
          if (loadInStartTime === null) {
            loadInStartTime = timeSeconds;
          }
          const elapsed = timeSeconds - loadInStartTime;
          const progress = Math.min(1.0, elapsed / LOAD_IN_DURATION);
          loadInProgress.value = progress;

          // Update the mesh to apply shader changes
          splatMesh.updateVersion();
        }

        // Movement from keyboard
        direction.set(0, 0, 0);
        if (moveState.forward) direction.z -= 1;
        if (moveState.backward) direction.z += 1;
        if (moveState.left) direction.x -= 1;
        if (moveState.right) direction.x += 1;

        // Add joystick input
        direction.x += joystickInput.x;
        direction.z -= joystickInput.y;

        if (direction.lengthSq() > 0) {
          if (direction.lengthSq() > 1) direction.normalize();
          direction.applyQuaternion(camera.quaternion);
          direction.y = 0;
          direction.normalize();
          camera.position.addScaledVector(direction, CONFIG.moveSpeed * delta);
        }

        // Check for nearby message bottles (explore mode)
        checkProximityMessages();

        // Update admin panel if active
        if (isAdminMode && window.adminUpdatePanel) {
          window.adminUpdatePanel();
        }

        // Render
        renderer.render(scene, camera);
      });

      // Cleanup on page unload
      window.addEventListener('beforeunload', () => {
        ghostPreview?.dispose();
        treatManager?.dispose();
        renderer.dispose();
        splatMesh?.dispose?.();
      });
    </script>
  </body>
</html>
